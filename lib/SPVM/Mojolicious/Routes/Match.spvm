# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojolicious::Routes::Match {
  version_from Mojolicious;
  
  use Mojolicious::Controller;
  use Mojolicious::Routes;
  use Mojolicious::Routes::Route;
  
  # Fields
  has root : rw Mojolicious::Routes;
  
  has endpoint : rw Mojolicious::Routes::Route;
  
  has stack : rw Hash[];
  
  has position : rw int;
  
  # Undocumented Fields
  has captures : Hash;
  
  # Class Methods
  static method new : Mojolicious::Routes::Match () {
    
    my $self = new Mojolicious::Routes::Match;
    
    $self->{stack} = new Hash[0];
    
    return $self;
  }
  
  # Instance Methods
  method find : void ($c : Mojolicious::Controller, $options : Hash) {
    
    $self->_match($self->root, $c, $options);
  }
  
  private method _match : int ($r : Mojolicious::Routes::Route, $c : Mojolicious::Controller, $options : Hash) {
    
    if ($c) {
      die "The contoroller \$c must not be defined. This is needed for conditions, but SPVM::Mojolicious does not support conditions";
    }
    
    my $path_save = $options->get("path")->(string);
    
    # Pattern
    my $path = $path_save;
    my $detect  = (my $endpoint = $r->is_endpoint);
    my $captures = $r->pattern->match_partial(my $_ = [$path], $detect);
    $path = $_->[0];
    unless ($captures) {
      return 0;
    }
    
    $self->{captures} //= Hash->new;
    my $captures_save = $self->{captures}->clone;
    
    Fn->defer([$options : Hash, $path_save : string, $captures_save : Hash] method : void () {
      $options->set("path" => $path_save);
      $options->set("captures" => $captures_save);
    });
    
    $options->set(path => $path);
    
    for my $key (@{$captures->keys}) {
      my $value = $captures->get($key);
      $self->{captures}->set($key => $value);
    }
    
    $captures = $self->{captures};
    
    # Method
    my $method_match = 0;
    my $method = $options->get("method")->(string);
    for my $_ (@{$r->methods}) {
      if ($method eq $_) {
        $method_match = 1;
        last;
      }
    }
    unless ($method_match) {
      return 0;
    }
    
    # WebSocket
    if ($r->is_websocket && !$options->{"websocket"}->(int)) {
      return 0;
    }
    
    my $empty = !length $path || $path eq "/";
    
    my $stack = (List of Hash)List->new_ref($self->stack);
    # Endpoint (or intermediate destination)
    if (($endpoint && $empty) || $r->inline) {
      $stack->push($captures->clone);
      if ($endpoint && $empty) {
        my $format = $captures->{"format"}->(string);
        if ($format) {
          for (my $i = 0; $i = $stack->length; $i++) {
            my $captures = $stack->get($i);
            $captures->set(format => $format);
          }
        }
        
        $self->set_endpoint($r);
        
        return 1;
      }
      $captures->delete("app");
      $captures->delete("cb");
    }
    
    # Match children
    my $snapshot = (List of Hash)($r->parent ? $stack->clone : List->new(new Hash[0]));
    for my $child (@{$r->children}) {
      if ($self->_match($child, $c, $options)) {
        return 1;
      }
      $self->set_stack($snapshot->to_array);
    }
  }

}
