# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojolicious::Routes::Match {
  version_from Mojolicious;
  
  use Mojolicious::Routes::Route;
  use Mojolicious::Routes::Match::Stack;
  
  # Fields
  has root : rw Mojolicious::Routes;
  
  has endpoint : rw Mojolicious::Routes::Route;
  
  has stack : rw Hash[];
  
  has position : rw int;
  
  # Undocumented Fields
  has captures : Hash;
  
  # Class Methods
  static method new : Mojolicious::Routes::Match () {
    
    my $self = new Mojolicious::Routes::Match;
    
    $self->{stack} = new Hash[0];
    
    return $self;
  }
  
  # Instance Methods
  method find : void ($options : Hash) {
    
    $self->_match($self->root, $options);
  }
  
  private method _match : int ($r : Mojolicious::Routes::Route, $options : Hash) {
    
    my $path = copy $options->get("path")->(string);
    my $path_save = copy $path;
    
    $self->{captures} //= Hash->new;
    my $captures_save = $self->{captures}->clone;
    
    Fn->defer([$self : Mojolicious::Routes::Match, $options : Hash, $path_save : string, $captures_save : Hash] method : void () {
      $options->{"path"} = $path_save;
      $self->{captures} = $captures_save;
    });
    
    # Pattern
    my $endpoint = $r->is_endpoint;
    my $captures = $r->pattern->match_partial((mutable string)$path);
    unless ($captures) {
      return 0;
    }
    
    $options->set(path => $path);
    
    for my $key (@{$captures->keys}) {
      my $value = $captures->{$key};
      $self->{captures}->{$key} = $value;
    }
    
    $captures = $self->{captures};
    
    # Method
    my $method_match = 0;
    my $method = $options->get("method")->(string);
    for my $_ (@{$r->methods}) {
      if ($method eq $_) {
        $method_match = 1;
        last;
      }
    }
    unless ($method_match) {
      return 0;
    }
    
    # WebSocket
    if ($r->is_websocket && !$options->{"websocket"}->(int)) {
      return 0;
    }
    
    my $empty = !length $path || $path eq "/";
    
    my $stack = (List of Hash)List->new_ref($self->stack);
    # Endpoint (or intermediate destination)
    if (($endpoint && $empty) || $r->inline) {
      $stack->push($captures->clone);
      if ($endpoint && $empty) {
        
        $self->set_endpoint($r);
        
        return 1;
      }
      $captures->delete("app");
      $captures->delete("cb");
    }
    
    # Match children
    my $snapshot = (List of Hash)($r->parent ? $stack->clone : List->new(new Hash[0]));
    for my $child (@{$r->children}) {
      if ($self->_match($child, $options)) {
        return 1;
      }
      $self->set_stack($snapshot->to_array);
    }
  }

}
