# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojolicious::Routes::Match {
  version_from Mojolicious;
  
  use Mojolicious::Controller;
  use Mojolicious::Routes;
  use Mojolicious::Routes::Route;
  
  # Fields
  has root : rw Mojolicious::Routes;
  
  has endpoint : rw Mojolicious::Routes::Route;
  
  has position : int;
  
  has stack : virtual rw Hash[]
    
    get {
      return (Hash[])$self->stack_list->to_array;
    }
    set {
      $self->set_stack_list(List->new($_));
    }
  ;
  
  has stack_list : rw List of Hash
    get {
      unless (exists $self->{stack_list}) {
        $self->{stack_list} = List->new(new Hash[0]);
      }
      
      return $self->{stack_list};
    }
  ;
  
  # Class Methods
  static method new : Mojolicious::Routes::Match () {
    
    my $self = new Mojolicious::Routes::Match;
    
    return $self;
  }
  
  # Instance Methods
  method find : void ($c : Mojolicious::Controller, $options : Hash) {
    $self->_match($self->root, $c, $options);
  }
  
  static method _hash_merge : void ($self : Hash, $hash : Hash) {
    
    for my $key (@{$hash->keys}) {
      my $value = $hash->get($key);
      $self->set($key, $value);
    }
  }
  
  static method _hash_merge_options : void ($self : Hash, $options : object[]) {
    
    my $hash = Hash->new($options);
    
    &_hash_merge($self, $hash);
  }
  
  method path_for : Hash ($args : object...) {
    
    my $_ = Mojo::Util->_options($args);
    my $name = (string)$_->[0];
    my $values = Hash->new((object[])$_->[1]);
    
    # Current route
    my $route = (Mojolicious::Routes::Route)undef;
    my $current = !$name || $name eq "current";
    
    if ($current) {
      unless ($route = $self->endpoint) {
        return Hash->new;
      }
    }
    
    # Find endpoint
    else {
      unless ($route = $self->root->lookup($name)) {
        return Hash->new({path => $name});
      }
    }
    
    # Merge values (clear format)
    my $stack_list = $self->stack_list;
    my $captures = (Hash)undef;
    if ($stack_list->length > 0) {
      $captures = (Hash)$stack_list->get($stack_list->length - 1) // Hash->new;
    }
    else {
      $captures = Hash->new;
    }
    
    my $merged = Hash->new;
    &_hash_merge($merged, $captures);
    &_hash_merge_options($merged, {format => undef});
    &_hash_merge($merged, $captures);
    
    my $pattern     = $route->pattern;
    my $constraints = $pattern->constraints;
    
    if (!$values->exists("format") && $constraints->get("format") && $constraints->get("format")->(string) ne "1") {
      $merged->set("format", ($current ? $captures->get("format") : undef) // $pattern->defaults->get("format"));
    }
    
    return Hash->new({path => $route->render($merged), websocket => $route->has_websocket});
  }
  
  private method _match : void ($r : Mojolicious::Routes, $c : Mojolicious::Controller, $options : Hash) {
    
=pod

    # Pattern
    my $path    = $options->{path};
    my $partial = $r->partial;
    my $detect  = (my $endpoint = $r->is_endpoint) && !$partial;
    return undef unless my $captures = $r->pattern->match_partial(\$path, $detect);
    local $options->{path} = $path;
    local @{$self->{captures} //= {}}{keys %$captures} = values %$captures;
    $captures = $self->{captures};

    # Method
    my $methods = $r->methods;
    return undef if $methods && !grep { $_ eq $options->{method} } @$methods;

    # Conditions
    if (my $over = $r->requires) {
      my $conditions = $self->{conditions} ||= $self->root->conditions;
      for (my $i = 0; $i < @$over; $i += 2) {
        return undef unless my $condition = $conditions->{$over->[$i]};
        return undef if !$condition->($r, $c, $captures, $over->[$i + 1]);
      }
    }

    # WebSocket
    return undef if $r->is_websocket && !$options->{websocket};

    # Partial
    my $empty = !length $path || $path eq '/';
    if ($partial) {
      $captures->{path} = $path;
      $self->endpoint($r);
      $empty = 1;
    }

    # Endpoint (or intermediate destination)
    if (($endpoint && $empty) || $r->inline) {
      push @{$self->stack}, {%$captures};
      if ($endpoint && $empty) {
        my $format = $captures->{format};
        if ($format) { $_->{format} = $format for @{$self->stack} }
        return !!$self->endpoint($r);
      }
      delete @$captures{qw(app cb)};
    }

    # Match children
    my $snapshot = $r->parent ? [@{$self->stack}] : [];
    for my $child (@{$r->children}) {
      return 1 if $self->_match($child, $c, $options);
      $self->stack([@$snapshot]);
    }

=cut

  }

}
