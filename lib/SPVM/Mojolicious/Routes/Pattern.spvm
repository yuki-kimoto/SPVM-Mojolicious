# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojolicious::Routes::Pattern {
  
  use Mojolicious::Types;
  
  # Fields
  has defaults : rw Hash;
  
  has constraints : rw Hash;
  
  has types : rw Hash;
  
  has placeholder_start : rw string
    get {
      unless (exists $self->{placeholder_start}) {
        $self->{placeholder_start} = ":";
      }
      
      return $self->{placeholder_start};
    }
  ;
  
  has type_start : rw string
    get {
      unless (exists $self->{type_start}) {
        $self->{type_start} = ":";
      }
      
      return $self->{type_start};
    }
  ;
  
  has placeholders : virtual rw string[]
    get {
      return $self->placeholders_list->to_array;
    }
    set {
      $self->set_placeholders_list(StringList->new($_));
    }
  ;
  
  has placeholders_list : rw StringList;
  
  has tree : rw string[][]
    get {
      return (string[][])$self->tree_list->to_array;
    }
    set {
      $self->set_tree_list(List->new($_));
    }
  ;
  
  has tree_list : rw List of string[];
  
  has quote_end : rw string
    get {
      unless (exists $self->{quote_end}) {
        $self->{quote_end} = ">";
      }
      
      return $self->{quote_end};
    }
  ;
  
  has quote_start : rw string
    get {
      unless (exists $self->{quote_start}) {
        $self->{quote_start} = "<";
      }
      
      return $self->{quote_start};
    }
  ;
  
  has regex : rw Regex;
  
  has unparsed : rw string;
  
  has relaxed_start : rw string
    get {
      unless (exists $self->{relaxed_start}) {
        $self->{relaxed_start} = "#";
      }
      
      return $self->{relaxed_start};
    }
  ;
  
  has wildcard_start : rw string
    get {
      unless (exists $self->{wildcard_start}) {
        $self->{wildcard_start} = "#";
      }
      
      return $self->{wildcard_start};
    }
  ;
  
  # Class Methods
  static method new : Mojolicious::Routes::Pattern ($args : object...) {
    
    my $self = new Mojolicious::Routes::Pattern;
    
    if (@$args) {
      $self->parse($args);
    }
    
    return $self;
  }
  
  # Instance Methods
  method match : Hash ($path : string, $detect : int = 0) {
    
    my $captures = $self->match_partial(my $_ = [$path], $detect);
    $path = $_->[0];
    
    return !$path || $path eq "/" ? $captures : undef;
  }
  
  method match_partial : Hash ($pathref : string[], $detect : int = 0) {
    
    # Compile on demand
    unless ($self->{regex}) {
      $self->_compile($detect);
    }
    
    my $captures_length = 0;
    my $match_start = -1;
    my $match_length = -1;
    my $captures_list = (StringList)undef;
    if (my $m = $self->regex->match($pathref->[0])) {
      $captures_length = $m->captures_length;
      $match_start = $m->match_start;
      $match_length = $m->match_length;
      
      $captures_list = StringList->new;
      
      for (my $i = 0; $i < $captures_length; $i++) {
        $captures_list->push($m->captures($i));
      }
    }
    
    unless ($captures_length) {
      return undef;
    }
    
    $pathref->[0] = Fn->substr($pathref->[0], $match_start, $match_length);
    
    my $captures_h = Hash->new($self->defaults->to_array);
    my $placeholders_list = StringList->new($self->placeholders);
    $placeholders_list->push("format");
    
    for my $placeholder (@{$placeholders_list->to_array}) {
      
      unless ($captures_list->length) {
        last;
      }
      
      my $capture = $captures_list->shift;
      
      if ($capture) {
        $captures_h->set($placeholder, $capture);
      }
    }
    
    return $captures_h;
  }

  private method _compile : void ($detect : int) {

=pod

    my $constraints = $self->constraints;
    my $defaults    = $self->defaults;
    my $types       = $self->types;

    my $block    = my $regex = '';
    my $optional = 1;
    for my $token (reverse @{$self->tree}) {
      my ($op, $value, $type) = @$token;
      my $part = '';

      # Text
      if ($op eq 'text') { ($part, $optional) = (quotemeta $value, 0) }

      # Slash
      elsif ($op eq 'slash') {
        $regex = ($optional ? "(?:/$block)?" : "/$block") . $regex;
        ($block, $optional) = ('', 1);
        next;
      }

      # Placeholder
      else {
        if ($value->[1]) { $part = _compile_req($types->{$value->[1]} // '?!') }
        else             { $part = $type ? $type eq 'relaxed' ? '([^/]+)' : '(.+)' : '([^/.]+)' }

        # Custom regex
        if (my $c = $constraints->{$value->[0]}) { $part = _compile_req($c) }

        # Optional placeholder
        exists $defaults->{$value->[0]} ? ($part .= '?') : ($optional = 0);
      }

      $block = $part . $block;
    }

    # Not rooted with a slash
    $regex = $block . $regex if $block;

    # Format
    $regex .= _compile_format($constraints->{format}, exists $defaults->{format}) if $detect;

    $self->regex(qr/^$regex/ps);

=cut

  }

  method parse : void ($args : object...) {
  
    my $args_list = List->new($args);
    
    my $pattern = $args_list->length % 2 ? ($args_list->shift->(string) // "/") : "/";
    
    Re->s(my $_ = [$pattern], ["^/*|/+", "g"], "/");
    $pattern = $_->[0];
    
    if ($pattern eq "/") {
      $self->set_constraints(Hash->new((object[])$args_list->get(0))) ;
      return;
    }
    
    Re->s(my $_ = [$pattern], "!/$", "");
    $pattern = $_->[0];
    
    $self->set_constraints(Hash->new((object[])$args_list->get(0)));
    
    $self->_tokenize($pattern);
  }
  
  method _tokenize : void ($pattern : string) {
    
    die "TODO";

=pod

    my $placeholders = $self->placeholders;
    my $type_start   = $self->type_start;
    my $quote_end    = $self->quote_end;
    my $quote_start  = $self->quote_start;
    my $start        = $self->placeholder_start;
    my $relaxed      = $self->relaxed_start;
    my $wildcard     = $self->wildcard_start;

    my (@tree, $spec, $more);
    for my $char (split //, $pattern) {

      # Quoted
      if    ($char eq $quote_start) { push @tree, ['placeholder', ''] if ++$spec }
      elsif ($char eq $quote_end)   { $spec = $more = 0 }

      # Placeholder
      elsif (!$more && $char eq $start) { push @tree, ['placeholder', ''] unless $spec++ }

      # Relaxed or wildcard (upgrade when quoted)
      elsif (!$more && ($char eq $relaxed || $char eq $wildcard)) {
        push @tree, ['placeholder', ''] unless $spec++;
        $tree[-1][2] = $char eq $relaxed ? 'relaxed' : 'wildcard';
      }

      # Slash
      elsif ($char eq '/') {
        push @tree, ['slash'];
        $spec = $more = 0;
      }

      # Placeholder
      elsif ($spec && ++$more) { $tree[-1][1] .= $char }

      # Text (optimize slash+text and *+text+slash+text)
      elsif ($tree[-1][0] eq 'text')                                         { $tree[-1][-1] .= $char }
      elsif (!$tree[-2] && $tree[-1][0] eq 'slash')                          { @tree = (['text', "/$char"]) }
      elsif ($tree[-2] && $tree[-2][0] eq 'text' && $tree[-1][0] eq 'slash') { pop @tree && ($tree[-1][-1] .= "/$char") }
      else                                                                   { push @tree, ['text', $char] }
    }

    # Placeholder types
    for my $token (reverse @tree) {
      next unless $token->[0] eq 'placeholder';
      $token->[1] = $token->[1] =~ /^(.+)\Q$type_start\E(.+)$/ ? [$1, $2] : [$token->[1]];
      unshift @$placeholders, $token->[1][0];
    }

    return $self->unparsed($pattern)->tree(\@tree);

=cut

  }

  method render : string ($values : object[], $endpoint : int = 0) {
    
    die "TODO";
  }

}

__END__

sub render {
  my ($self, $values, $endpoint) = @_;

  # Placeholders can only be optional without a format
  my $optional = !(my $format = $values->{format});

  my $str = '';
  for my $token (reverse @{$self->tree}) {
    my ($op, $value) = @$token;
    my $part = '';

    # Text
    if ($op eq 'text') { ($part, $optional) = ($value, 0) }

    # Slash
    elsif ($op eq 'slash') { $part = '/' unless $optional }

    # Placeholder
    else {
      my $name    = $value->[0];
      my $default = $self->defaults->{$name};
      $part = $values->{$name} // $default // '';
      if    (!defined $default || ($default ne $part)) { $optional = 0 }
      elsif ($optional)                                { $part     = '' }
    }

    $str = $part . $str;
  }

  # Format can be optional
  return $endpoint && $format ? "$str.$format" : $str;
}

sub _compile_format {
  my ($format, $has_default) = @_;

  # No regex
  return '' unless $format;

  # Default regex
  return '/?(?:\.([^/]+))?$' if $format eq '1';

  # Compile custom regex
  my $regex = '\.' . _compile_req($format);
  return $has_default ? "/?(?:$regex)?\$" : "/?$regex\$";
}

sub _compile_req {
  my $req = shift;
  return "($req)" if ref $req ne 'ARRAY';
  return '(' . join('|', map {quotemeta} reverse sort @$req) . ')';
}

