# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojolicious::Routes::Pattern {
  
  use Mojolicious::Types;
  
  # Fields
  has defaults : rw Hash;
  
  has constraints : rw Hash;
  
  has placeholder_start : rw string;
  
  has placeholders : rw string[];
  
  has quote_end : rw string;
  
  has quote_start : rw string;
  
  has regex : rw Regex;
  
  has unparsed : rw string;
  
  has relaxed_start : rw string;
  
  has wildcard_start : rw string;
  
  # Undocumented Fields
  has tree : rw List of string[];
  
  # Class Methods
  static method new : Mojolicious::Routes::Pattern ($pattern : string = undef, $constrants : Hash = undef) {
    
    my $self = new Mojolicious::Routes::Pattern;
    
    if ($pattern || $constrants) {
      $self->parse($pattern, $constrants);
    }
    
    $self->{placeholder_start} = ":";
    
    $self->{quote_end} = ">";
    
    $self->{quote_start} = "<";
    
    $self->{relaxed_start} = "#";
    
    $self->{wildcard_start} = "*";
    
    $self->{placeholders} = new string[0];
    
    $self->{constraints} = Hash->new;
    
    $self->{defaults} = Hash->new;
    
    return $self;
  }
  
  private static method _compile_req : string ($req : string|string[]) {
    
    if ($req isa string) {
      return "(" . (string)$req . ")";
    }
    
    my $reqs = Array->copy_string_address((string[])$req);
    
    Sort->sort_string_desc($reqs);
    
    for (my $i = 0; $i < @$reqs; $i++) {
      $reqs->[$i] = "\Q" . $reqs->[$i] . "\E";
    }
    
    return "(" . Fn->join("|", $reqs) . ")";
  }
  
  private static method _compile_format : string ($format : string|string[], $has_default : int) {
    
    # No regex
    unless ($format) {
      return "";
    }
    
    # Default regex
    if ($format isa string && (string)$format eq "1") {
      return "/?(?:\.([^/]+))?$" ;
    }
    
    # Compile custom regex
    my $regex = "\." . &_compile_req($format);
    
    return $has_default ? "/?(?:$regex)?\$" : "/?$regex\$";
  }
  
  # Instance Methods
  method match : Hash ($path : string, $detect : int = 0) {
    
    my $captures = $self->match_partial(my $_ = [$path], $detect);
    $path = $_->[0];
    
    return !$path || $path eq "/" ? $captures : undef;
  }
  
  method match_partial : Hash ($pathref : string[], $detect : int = 0) {
    
    # Compile on demand
    unless ($self->{regex}) {
      $self->_compile($detect);
    }
    
    my $captures_length = 0;
    my $match_start = -1;
    my $match_length = -1;
    my $captures_list = (StringList)undef;
    if (my $m = $self->regex->match($pathref->[0])) {
      $captures_length = $m->captures_length;
      $match_start = $m->match_start;
      $match_length = $m->match_length;
      
      $captures_list = StringList->new;
      
      for (my $i = 0; $i < $captures_length; $i++) {
        $captures_list->push($m->captures->[$i]);
      }
    }
    
    unless ($captures_length) {
      return undef;
    }
    
    $pathref->[0] = Fn->substr($pathref->[0], $match_start, $match_length);
    
    my $captures_h = Hash->new($self->defaults->to_array);
    my $placeholders = StringList->new($self->placeholders);
    $placeholders->push("format");
    
    for my $placeholder (@{$placeholders->get_array}) {
      
      unless ($captures_list->length) {
        last;
      }
      
      my $capture = $captures_list->shift;
      
      if ($capture) {
        $captures_h->{$placeholder} = $capture;
      }
    }
    
    return $captures_h;
  }

  method parse : void ($pattern : string, $constrants : Hash = undef) {
    
    $pattern //= "/";
    
    $pattern = copy $pattern;
    
    Re->s((mutable string)$pattern, ["^/*|/+", "g"], "/");
    
    if ($pattern eq "/") {
      $self->set_constraints($constrants->clone) ;
      return;
    }
    
    Re->s((mutable string)$pattern, "!/$", "");
    
    $self->set_constraints($constrants->clone);
    
    $self->_tokenize($pattern);
  }
  
  private method _compile : void ($detect : int) {

    my $constraints = $self->constraints;
    
    my $defaults    = $self->defaults;
    
    my $block    = my $regex = "";
    
    my $optional = 1;
    
    my $tree = $self->{tree};
    
    for (my $i = @$tree - 1; $i >= 0; $i--) {
      my $token = (object[])$tree->[$i];
      
      my $op = (string)$token->[0];
      my $value = $token->[1];
      my $type = (string)$token->[2];
      
      my $part = "";
      
      # Text
      if ($op eq "text") {
        $part = "\Q" . (string)$value . "\E";
        $optional = 0;
      }
      
      # Slash
      elsif ($op eq "slash") {
        $regex = ($optional ? "(?:/$block)?" : "/$block") . $regex;
        $block = "";
        $optional = 1;
        next;
      }
      
      # Placeholder
      else {
        my $value = (string[])$value;
        $part = $type ? $type eq "relaxed" ? "([^/]+)" : "(.+)" : "([^/.]+)";
        
        # Custom regex
        if (my $c = $constraints->{$value->[0]}) { $part = &_compile_req($c); }
        
        # Optional placeholder
        if ($defaults->exists($value->[0])) {
          $part .= "?";
        }
        else {
          $optional = 0;
        }
      }
      
      $block = $part . $block;
    }
    
    # Not rooted with a slash
    if ($block) {
      $regex = $block . $regex;
    }
    
    # Format
    if ($detect) {
      $regex .= &_compile_format($constraints->{"format"}, $defaults->exists("format")) ;
    }
    
    $self->set_regex(Regex->new($regex));
  }
  
  method _tokenize : void ($pattern : string) {
    
    my $placeholders = StringList->new_ref($self->placeholders);
    my $quote_end    = $self->quote_end;
    my $quote_start  = $self->quote_start;
    my $start        = $self->placeholder_start;
    my $relaxed      = $self->relaxed_start;
    my $wildcard     = $self->wildcard_start;
    
    my $tree = (List of string[])List->new;
    my $spec = 0;
    my $more = 0;
    for (my $i = 0; $i < length $pattern; $i++) {
      my $char = Fn->substr($pattern, $i, 1);
      
      # Quoted
      if ($char eq $quote_start) {
        if (++$spec) {
          $tree->push(["placeholder", "", undef]);
        }
      }
      elsif ($char eq $quote_end)   { $spec = $more = 0; }
      
      # Placeholder
      elsif (!$more && $char eq $start) {
        unless ($spec++) {
          $tree->push(["placeholder", "", undef]);
        }
      }
      
      # Relaxed or wildcard (upgrade when quoted)
      elsif (!$more && ($char eq $relaxed || $char eq $wildcard)) {
        unless ($spec++) {
          $tree->push(["placeholder", "", undef]);
        }
        $tree->[-1][2] = $char eq $relaxed ? "relaxed" : "wildcard";
      }
      
      # Slash
      elsif ($char eq "/") {
        $tree->push(["slash", undef, undef]);
        $spec = $more = 0;
      }
      
      # Placeholder
      elsif ($spec && ++$more) {
        my $_ = $tree->[-1][1];
        $tree->[-1][1] =  $_ . $char;
      }

      # Text (optimize slash+text and *+text+slash+text)
      elsif ($tree->[-1][0] eq "text") {
        my $token = $tree->[-1];
        $token->[-1] .= $char;
      }
      elsif (!$tree->[@$tree - 2] && $tree->[-1][0] eq "slash") {
        $tree = (List of string[])List->new(["text", "/$char", undef]);
      }
      elsif (@$tree >= 2 && $tree->[-2][0] eq "text" && $tree->[-1][0] eq "slash") {
        if (@$tree) {
          $tree->pop;
          my $_ = $tree->[-1][@$tree];
          my $token = $tree->[-1];
          $token->[-1] = "$_/$char";
        }
      }
      else {
        $tree->push(["text", $char, undef]);
      }
    }
    
    $self->set_unparsed($pattern);
    
    $self->set_tree($tree);
  }
  
  method render : string ($values : Hash, $endpoint : int) {
    
    # Placeholders can only be optional without a format
    my $optional = !(my $format = $values->{"format"}->(string));
    
    my $str = "";
    my $tree = $self->tree;
    for (my $i = @$tree - 1; $i >= 0; $i--) {
      my $token = $tree->[$i];
      
      my $op = $token->[0];
      my $value = $token->[1];
      
      my $part = "";
      
      # Text
      if ($op eq "text") {
        $part = $value;
        $optional = 0;
      }
      
      # Slash
      elsif ($op eq "slash") {
        unless ($optional) {
          $part = "/";
        }
      }
      
      # Placeholder
      else {
        my $name = $value;
        my $default = $self->defaults->{$name}->(string);
        
        $part = $values->{$name}->(string) // $default // "";
        
        if (!$default || ($default ne $part)) {
          $optional = 0;
        }
        elsif ($optional) {
          $part = "";
        }
      }
      
      $str = $part . $str;
    }
    
    # Format can be optional
    return $endpoint && $format ? "$str.$format" : $str;
  }

}
