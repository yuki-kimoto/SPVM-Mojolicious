# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojolicious::Routes::Route {
  version_from Mojolicious;
  
  use Mojo::Util;
  use Mojolicious::Routes::Pattern;
  
  # Class Variables
  # Reserved stash values
  our $RESERVED : Hash of string;
  INIT {
    
    my $reserved = [
      "action",
      "app",
      "cb",
      "controller",
      "data",
      "extends",
      "format",
      "handler",
      "inline",
      "json",
      "layout",
      "namespace",
      "path",
      "status",
      "template",
      "text",
      "variant",
    ];
    
    $RESERVED = Hash->new_from_keys($reserved => 1);
  }
  
  # Fields
  has inline : rw byte;
  
  has partial : rw byte;
  
  has children : rw Mojolicious::Routes::Route[]
    get {
      unless (exists $self->{children}) {
        $self->{children} = new Mojolicious::Routes::Route[0];
      }
      
      return $self->{children};
    }
  ;
  
  has parent : rw Mojolicious::Routes::Route
    get {
      unless (exists $self->{parent}) {
        $self->{parent} = undef;
      }
      
      return $self->{parent};
    }
    set {
      $self->{parent} = $_;
      weaken $self->{parent};
    }
  ;
  
  has pattern : rw Mojolicious::Routes::Pattern
    get {
      unless (exists $self->{pattern}) {
        $self->{pattern} = Mojolicious::Routes::Pattern->new;
      }
      
      return $self->{pattern};
    }
  ;
  
  # Undocumented Fields
  has websocket : byte;
  
  # Instance Methods
  method is_reserved : int ($name : string) {
    die "Not implemeneted.";
  }
  
  method any : Mojolicious::Routes::Route ($args : object...) {
    
    my $methods = (string[])undef;
    my $shift = 0;
    if ($args->[0] isa string[]) {
      $methods = (string[])$args->[0];
      $shift = 1;
    }
    else {
      $methods = new string[0];
    }
    
    $args = $shift ? (object...)Array->copy_object_address($args, 1, @$args - 1) : $args;
    
    return $self->_generate_route($methods, $args);
  }
  
  method delete : Mojolicious::Routes::Route ($args : object...) {
    return $self->_generate_route(DELETE => $args);
  }
  
  method get : Mojolicious::Routes::Route ($args : object...) {
    return $self->_generate_route(GET => $args);
  }
  
  method options : Mojolicious::Routes::Route ($args : object...) {
    return $self->_generate_route(OPTIONS => $args);
  }
  
  method patch : Mojolicious::Routes::Route ($args : object...) {
    return $self->_generate_route(PATCH => $args);
  }
  
  method post : Mojolicious::Routes::Route ($args : object...) {
    return $self->_generate_route(POST => $args);
  }
  
  method put : Mojolicious::Routes::Route ($args : object...) {
    return $self->_generate_route(PUT => $args);
  }
  
  method under : Mojolicious::Routes::Route ($args : object...) {
    return $self->_generate_route(under => $args);
  }
  
  method websocket : Mojolicious::Routes::Route ($args : object...) {
    
    my $route = $self->get($args);
    
    $route->{websocket} = 1;
    
    return $route;
  }
  
  private method _generate_route : Mojolicious::Routes::Route ($method : object of string|string[], $args : object[]) {
    die "TODO";
  }

}

__END__

TODO

sub BUILD_DYNAMIC {
  my ($class, $method, $dyn_methods) = @_;

  return sub {
    my $self    = shift;
    my $dynamic = $dyn_methods->{$self->root}{$method};
    return $self->$dynamic(@_) if $dynamic;
    my $package = ref($self);
    croak qq{Can't locate object method "$method" via package "$package"};
  };
}

sub add_child {
  my ($self, $route) = @_;
  push @{$self->children}, $route->remove->parent($self);
  $route->pattern->types($self->root->types);
  return $self;
}

sub any { shift->_generate_route(ref $_[0] eq 'ARRAY' ? shift : [], @_) }

sub delete { shift->_generate_route(DELETE => @_) }

sub find { shift->_index->{shift()} }

sub get { shift->_generate_route(GET => @_) }

sub has_custom_name { !!shift->{custom} }

sub has_websocket {
  my $self = shift;
  return $self->{has_websocket} if exists $self->{has_websocket};
  return $self->{has_websocket} = grep { $_->is_websocket } @{$self->_chain};
}

sub is_endpoint { $_[0]->inline ? undef : !@{$_[0]->children} }

sub is_reserved { !!$RESERVED{$_[1]} }

sub is_websocket { !!shift->{websocket} }

sub methods {
  my $self = shift;
  return $self->{methods} unless @_;
  my $methods = [map uc($_), @{ref $_[0] ? $_[0] : [@_]}];
  $self->{methods} = $methods if @$methods;
  return $self;
}

sub name {
  my $self = shift;
  return $self->{name} unless @_;
  @$self{qw(name custom)} = (shift, 1);
  return $self;
}

sub options { shift->_generate_route(OPTIONS => @_) }

sub parse {
  my $self = shift;
  $self->{name} = $self->pattern->parse(@_)->unparsed // '';
  $self->{name} =~ s/\W+//g;
  return $self;
}

sub patch { shift->_generate_route(PATCH => @_) }
sub post  { shift->_generate_route(POST  => @_) }
sub put   { shift->_generate_route(PUT   => @_) }

sub remove {
  my $self = shift;
  return $self unless my $parent = $self->parent;
  @{$parent->children} = grep { $_ ne $self } @{$parent->children};
  return $self->parent(undef);
}

sub render {
  my ($self, $values) = @_;
  my $path = join '', map { $_->pattern->render($values, !@{$_->children} && !$_->partial) } @{$self->_chain};
  return $path || '/';
}

sub root { shift->_chain->[0] }

sub requires {
  my $self = shift;

  # Routes with conditions can't be cached
  return $self->{requires} unless @_;
  my $conditions = ref $_[0] eq 'ARRAY' ? $_[0] : [@_];
  return $self unless @$conditions;
  $self->{requires} = $conditions;
  $self->root->cache->max_keys(0);

  return $self;
}

sub suggested_method {
  my $self = shift;

  my %via;
  for my $route (@{$self->_chain}) {
    next unless my @via = @{$route->methods // []};
    %via = map { $_ => 1 } keys %via ? grep { $via{$_} } @via : @via;
  }

  return 'POST' if $via{POST} && !$via{GET};
  return $via{GET} ? 'GET' : (sort keys %via)[0] || 'GET';
}

sub to {
  my $self = shift;

  my $pattern = $self->pattern;
  return $pattern->defaults unless @_;
  my ($shortcut, %defaults) = Mojo::Util::_options(@_);

  if ($shortcut) {

    # Application
    if (ref $shortcut || $shortcut =~ /^[\w:]+$/) { $defaults{app} = $shortcut }

    # Controller and action
    elsif ($shortcut =~ /^([\w\-:]+)?\#(\w+)?$/) {
      $defaults{controller} = $1 if defined $1;
      $defaults{action}     = $2 if defined $2;
    }
  }

  @{$pattern->defaults}{keys %defaults} = values %defaults;

  return $self;
}

sub to_string {
  join '', map { $_->pattern->unparsed // '' } @{shift->_chain};
}

sub under { shift->_generate_route(under => @_) }

sub websocket {
  my $route = shift->get(@_);
  $route->{websocket} = 1;
  return $route;
}

sub _chain {
  my @chain = (my $parent = shift);
  unshift @chain, $parent while $parent = $parent->parent;
  return \@chain;
}

sub _generate_route {
  my ($self, $methods, @args) = @_;

  my (@conditions, @constraints, %defaults, $name, $pattern);
  while (defined(my $arg = shift @args)) {

    # First scalar is the pattern
    if (!ref $arg && !$pattern) { $pattern = $arg }

    # Scalar
    elsif (!ref $arg && @args) { push @conditions, $arg, shift @args }

    # Last scalar is the route name
    elsif (!ref $arg) { $name = $arg }

    # Callback
    elsif (ref $arg eq 'CODE') { $defaults{cb} = $arg }

    # Constraints
    elsif (ref $arg eq 'ARRAY') { push @constraints, @$arg }

    # Defaults
    elsif (ref $arg eq 'HASH') { %defaults = (%defaults, %$arg) }
  }

  my $route = $self->_route($pattern, @constraints)->requires(\@conditions)->to(\%defaults);
  $methods eq 'under' ? $route->inline(1) : $route->methods($methods);

  return defined $name ? $route->name($name) : $route;
}

sub _index {
  my $self = shift;

  my (%auto, %custom);
  my @children = (@{$self->children});
  while (my $child = shift @children) {
    if   ($child->has_custom_name) { $custom{$child->name} ||= $child }
    else                           { $auto{$child->name}   ||= $child }
    push @children, @{$child->children};
  }

  return {%auto, %custom};
}

sub _route {
  my $self = shift;

  my $route       = $self->add_child(__PACKAGE__->new->parse(@_))->children->[-1];
  my $new_pattern = $route->pattern;
  croak qq{Route pattern "@{[$new_pattern->unparsed]}" contains a reserved stash value}
    if grep { $self->is_reserved($_) } @{$new_pattern->placeholders};

  my $old_pattern = $self->pattern;
  my $constraints = $old_pattern->constraints;
  $new_pattern->constraints->{format} //= $constraints->{format} if exists $constraints->{format};
  my $defaults = $old_pattern->defaults;
  $new_pattern->defaults->{format} //= $defaults->{format} if exists $defaults->{format};

  return $route;
}


