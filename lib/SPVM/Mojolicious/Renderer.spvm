# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojolicious::Renderer {
  version_from Mojolicious;
  
  use Mojo::Cache;
  use Mojo::File;
  use JSON;
  use Mojo::Util;
  use Mojo::Loader;
  use Mojo::Template;
  
  # Fields
  has cache : rw Mojo::Cache;
  
  has compress : rw byte;
  
  has default_format : rw string;
  
  has default_handler : rw string;
  
  has handlers : rw Hash of Mojo::Callback;
  
  has helpers : rw Hash of Mojo::Callback;
  
  has min_compress_size : rw int;
  
  has paths : virtual rw string[]
    get {
      return $self->paths_list->to_array->(string[]);
    }
    set {
      $self->{paths_list} = StringList->new($_);
    }
  ;
  
  has paths_list : rw StringList;
  
  has data_section : rw string;
  
  # Undocumented Fields
  has templates : Hash of string[];
  
  # Class Methods
  static method new : Mojolicious::Renderer () {
    
    my $self = new Mojolicious::Renderer;
    
    $self->{cache} = Mojo::Cache->new;
    
    $self->{compress} = 1;
    
    $self->{default_format} = "html";
    
    $self->{handlers} = Hash->new;
    
    $self->{helpers} = Hash->new;
    
    $self->{min_compress_size} = 860;
    
    $self->{paths_list} = StringList->new;
    
    $self->{templates} = Hash->new;
    
    return $self;
  }
  
  method accepts : string[] ($c : Mojolicious::Controller, $preferences : string[] = undef) {
    
    # List representations
    my $req   = $c->req;
    my $fmt = $req->param("_format");
    my $exts_list = StringList->new;
    if ($fmt) {
      $exts_list->push($fmt);
    }
    $exts_list->push_($c->app->types->detect($req->headers->accept));
    
    $preferences //= new string[0];
    unless (@$preferences) {
      return $exts_list->to_array;
    }
    
    # Find best representation
    for (my $i = 0; $i < $exts_list->length; $i++) {
      my $ext = $exts_list->get($i);
      
      for my $_ (@$preferences) {
        if ($ext eq $_) {
          return [$ext];
        }
      }
    }
    
    return $exts_list->length ? new string[0] : [$preferences->[0]];
  }
  
  method add_handler : void ($name : string, $cb : Mojo::Callback) {
    
    $self->{handlers}->set($name, $cb);
  }
  
  method add_helper : void ($name : string, $cb : Mojo::Callback) {
    
    $self->{helpers}->set($name, $cb);
  }
  
  method get_data_template : string ($options : object[]) {
    
    my $template = $self->template_name($options);
    
    unless ($template) {
      return undef;
    }
    
    return Mojo::Util->get_data_template($self->data_section, $template);
  }
  
  method template_name : string ($options : Hash|object[]) {
    
    my $options_h = &to_hash($options);
    
    my $template = $options_h->get_string("template");
    unless ($template) {
      return undef;
    }
    
    my $format = $options_h->get_string("format");
    unless ($format) {
      return undef;
    }
    
    $template .= ".$format";
    
    # Variants
    my $handler = $options_h->get_string("handler");
    
    return $handler ? "$template.$handler" : $template;
  }
  
  method get_helper : Mojo::Callback ($name : string) {
    
    return $self->{helpers}->get($name);
  }
  
  method render : string[] ($c : Mojolicious::Controller) {
    
    my $stash   = $c->stash;
    my $options_h = Hash->new({
      handler  => $stash->get_string("handler"),
      template => (string)$stash->delete("template"),
    });
    
    my $inline = (string)$stash->delete("inline");
    $options_h->set(inline => $inline);
    
    if ($inline) {
      if ($options_h->get("handler")) {
        $options_h->set("handler", $self->default_handler);
      }
    }
    
    $options_h->set(format => $stash->get_string("format") // $self->default_format);
    
    # Data
    if ($stash->get("data")) {
      return [(string)$stash->delete("data"), $options_h->get_string("format")];
    }
    
    # Text
    if ($stash->get("text")) {
      return [(string)$stash->delete("text"), $options_h->get_string("format")];
    }
    
    # JSON
    if ($stash->get("json")) {
      return [JSON->new->encode($stash->get("json")), "json"];
    }
    
    my $output = (string)undef;
    my $success = $self->_render_template($c, my $_ = [$output], $options_h);
    unless ($success) {
      return undef;
    }
    $output = $_->[0];
    
=pod TODO

    # Inheritance
    my $content = $stash->{'mojo.content'} //= {};
    local $content->{content} = $output =~ /\S/ ? $output : undef if $stash->{extends} || $stash->{layout};
    while ((my $next = _next($stash)) && !defined $inline) {
      @$options_h{qw(handler template)} = ($stash->{handler}, $next);
      $options_h->{format} = $stash->{format} || $self->default_format;
      if ($self->_render_template($c, \my $tmp, $options_h)) { $output = $tmp }
      $content->{content} //= $output if $output =~ /\S/;
    }

=cut
    
    if ($stash->get_int("mojo.string")) {
      return [$output, undef];
    }
    
    return [$output, $options_h->get_string("format")];
    
  }

  private method _render_template : int ($c : Mojolicious::Controller, $output_ref : string[], $options_h : Hash) {
    
    my $handler = $self->template_handler($options_h);
    
    unless ($options_h->get("handler")) {
      $options_h->set("handler", $handler);
    }
    
    unless ($handler) {
      return 0;
    }
    
    my $renderer = $self->handlers->get($handler);
    
    unless ($renderer) {
      $c->log->error("No handler for '$handler' found.");
      return 0;
    }
    
    my $output = (string)undef;
    $renderer->($self, $c, my $_ = [$output], $options_h);
    $output = $_->[0];
    
    if ($output) {
      return 1;
    }
    else {
      return 0;
    }
  }
  
  private static method to_hash : Hash ($options : Hash|object[]) {
    
    my $options_h = (Hash)undef;
    if (!$options) {
      $options_h = Hash->new;
    }
    elsif ($options isa Hash) {
      $options_h = (Hash)$options;
    }
    elsif ($options isa object[]) {
      $options_h = Hash->new((object[])$options);
    }
    else {
      die "The type of the options \$options must be Hash or object[].";
    }
    
    return $options_h;
  }
  
  method template_handler : string ($options : Hash|object[] = undef) {
    
    my $options_h = &to_hash($options);
    
    my $file = $self->template_name($options_h);
    unless ($file) {
      return undef;
    }
    
    my $templates = $self->{templates};
    
    my $handlers = $templates->get($file);
    
    unless ($handlers) {
      return $self->default_handler;
    }
    
    return $handlers->[0];
  }

}

__END__

sub respond {
  my ($self, $c, $output, $format, $status) = @_;

  croak 'A response has already been rendered' if $c->stash->{'mojo.respond'}++;

  # Gzip compression
  my $res = $c->res;
  if ($self->compress && length($output) >= $self->min_compress_size) {
    my $headers = $res->headers;
    $headers->append(Vary => 'Accept-Encoding');
    my $gzip = ($c->req->headers->accept_encoding // '') =~ /gzip/i;
    if ($gzip && !$headers->content_encoding) {
      $headers->content_encoding('gzip');
      $output = gzip $output;
    }
  }

  $res->body($output);
  $c->app->types->content_type($c, {ext => $format});
  return !!$c->rendered($status);
}

sub template_path {
  my ($self, $options) = @_;
  return undef unless my $name = $self->template_name($options);
  my @parts = split /\//, $name;
  -r and return $_ for map { path($_, @parts)->to_string } @{$self->paths}, $TEMPLATES;
  return undef;
}

sub _next {
  my $stash = shift;
  return delete $stash->{extends} if $stash->{extends};
  return undef unless my $layout = delete $stash->{layout};
  return join '/', 'layouts', $layout;
}

