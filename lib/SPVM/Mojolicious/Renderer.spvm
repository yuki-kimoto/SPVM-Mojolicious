# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojolicious::Renderer {
  version_from Mojolicious;
  
  use Mojo::File;
  use JSON;
  use Mojo::Util;
  use Mojo::Loader;
  use Mojo::Template;
  use Sys;
  
  # Fields
  has compress : rw byte;
  
  has default_format : rw string;
  
  has default_handler : rw string;
  
  has handlers : rw Hash of Mojo::Callback;
  
  has min_compress_size : rw int;
  
  has paths : rw string[];
  
  # Undocumented Fields
  has templates : Hash of string[];
  
  # Class Methods
  static method new : Mojolicious::Renderer () {
    
    my $self = new Mojolicious::Renderer;
    
    $self->{compress} = 1;
    
    $self->{default_format} = "html";
    
    $self->{default_handler} = "ep";
    
    $self->{handlers} = Hash->new;
    
    $self->{min_compress_size} = 860;
    
    $self->{paths} = new string[0];
    
    $self->{templates} = Hash->new;
    
    return $self;
  }
  
  method accepts : string[] ($c : Mojolicious::Controller, $preferences : string[] = undef) {
    
    # List representations
    my $req   = $c->req;
    my $fmt = $req->param("_format");
    my $exts_list = StringList->new;
    if ($fmt) {
      $exts_list->push($fmt);
    }
    $exts_list->push_($c->app->types->detect($req->headers->accept));
    
    $preferences //= new string[0];
    unless (@$preferences) {
      return $exts_list->to_array;
    }
    
    # Find best representation
    for (my $i = 0; $i < $exts_list->length; $i++) {
      my $ext = $exts_list->get($i);
      
      for my $_ (@$preferences) {
        if ($ext eq $_) {
          return [$ext];
        }
      }
    }
    
    return $exts_list->length ? new string[0] : [$preferences->[0]];
  }
  
  method add_handler : void ($name : string, $cb : Mojo::Callback) {
    
    $self->{handlers}->set($name, $cb);
  }
  
  method get_data_template : string ($options : object[], $data : string = undef) {
    
    my $template = $self->template_name($options);
    
    unless ($template) {
      return undef;
    }
    
    return Mojo::Util->get_data_template($data, $template);
  }
  
  method template_name : string ($options : Hash|object[]) {
    
    my $options_h = Fn->to_hash($options);
    
    my $template = $options_h->{"template"}->(string);
    unless ($template) {
      return undef;
    }
    
    my $format = $options_h->{"format"}->(string);
    unless ($format) {
      return undef;
    }
    
    $template .= ".$format";
    
    # Variants
    my $handler = $options_h->{"handler"}->(string);
    
    return $handler ? "$template.$handler" : $template;
  }
  
  method render : string[] ($c : Mojolicious::Controller) {
    
    my $stash   = $c->stash_h;
    my $options = Hash->new({
      handler  => $stash->{"handler"}->(string),
      template => (string)$stash->delete("template"),
    });
    
    my $inline = (string)$stash->delete("inline");
    $options->set(inline => $inline);
    
    if ($inline) {
      if ($options->get("handler")) {
        $options->set("handler", $self->default_handler);
      }
    }
    
    $options->set(format => $stash->{"format"}->(string) // $self->default_format);
    
    # Data
    if ($stash->get("data")) {
      return [(string)$stash->delete("data"), $options->{"format"}->(string)];
    }
    
    # Text
    if ($stash->get("text")) {
      return [(string)$stash->delete("text"), $options->{"format"}->(string)];
    }
    
    # JSON
    if ($stash->get("json")) {
      return [JSON->new->encode($stash->get("json")), "json"];
    }
    
    my $output = (string)undef;
    my $success = $self->_render_template($c, my $_ = [$output], $options);
    unless ($success) {
      return undef;
    }
    $output = $_->[0];
    
    # Inheritance
    unless ($stash->{"mojo.content"}) {
      $stash->{"mojo.content"} = Hash->new;
    }
    my $content = $stash->{"mojo.content"}->(Hash);
    
    my $content_save = $content->{"content"}->(string);
    my $restore = $stash->{"extends"}->(int) || $stash->{"layout"}->(int);
    Fn->defer([$content : Hash, $content_save : string, $restore : int] method : void () {
      if ($restore) {
        $content->{"content"} = $content_save;
      }
    });
    
    if ($restore) {
      $content->{"content"} = Re->m($output, "\S") ? $output : undef;
    }
    
    while ((my $next = &_next($stash)) && !$inline) {
      
      $options->{"handler"} = $stash->{"handler"};
      
      $options->{"template"} = $next;
      
      $options->{"format"} = $stash->{"format"} // $self->default_format;
      
      if ($self->_render_template($c, my $_ = [(string)undef], $options)) {
        $output = $_->[0];
      }
      
      if (Re->m($output, "\S")) {
        $content->{"content"} //= $output;
      }
    }
    
    if ($stash->{"mojo.string"}->(int)) {
      return [$output, undef];
    }
    
    return [$output, $options->{"format"}->(string)];
    
  }
  
  private static method _next : string ($stash : Hash) {
    
    if ($stash->{"extends"}) {
      return $stash->delete("extends")->(string);
    }
    
    my $layout = $stash->delete("layout")->(string);
    
    unless ($layout) {
      return undef;
    }
    
    return Fn->join("/", ["layouts", $layout]);
  }
  
  private method _render_template : int ($c : Mojolicious::Controller, $output_ref : string[], $options_h : Hash) {
    
    my $handler = $self->template_handler($options_h);
    
    unless ($options_h->get("handler")) {
      $options_h->set("handler", $handler);
    }
    
    unless ($handler) {
      return 0;
    }
    
    my $renderer = $self->handlers->get($handler);
    
    unless ($renderer) {
      $c->log->error("No handler for '$handler' found.");
      return 0;
    }
    
    my $output = (string)undef;
    $renderer->($self, $c, my $_ = [$output], $options_h);
    $output = $_->[0];
    
    if ($output) {
      return 1;
    }
    else {
      return 0;
    }
  }
  
  method template_handler : string ($options : Hash|object[]) {
    
    my $options_h = Fn->to_hash($options);
    
    my $file = $self->template_name($options_h);
    unless ($file) {
      return undef;
    }
    
    my $templates = $self->{templates};
    
    my $handlers = $templates->{$file};
    
    unless ($handlers) {
      return $self->default_handler;
    }
    
    return $handlers->[0];
  }
  
  method respond : void ($c : Mojolicious::Controller, $output : string, $format : string, $statsu : int) {
    
=pod

    croak 'A response has already been rendered' if $c->stash->{'mojo.respond'}++;
    
    # Gzip compression
    my $res = $c->res;
    if ($self->compress && length($output) >= $self->min_compress_size) {
      my $headers = $res->headers;
      $headers->append(Vary => 'Accept-Encoding');
      my $gzip = ($c->req->headers->accept_encoding // '') =~ /gzip/i;
      if ($gzip && !$headers->content_encoding) {
        $headers->content_encoding('gzip');
        $output = gzip $output;
      }
    }
    
    $res->body($output);
    $c->app->types->content_type($c, {ext => $format});
    return !!$c->rendered($status);
  }

=cut
  
  }
  
  method template_path : string ($options : Hash|object[] = undef) {
    
    my $options = Fn->to_hash($options);
    
    my $name = $self->template_name($options);
    
    unless ($name) {
      return undef;
    }
    
    my $parts = Fn->split("/", $name);
    
    for my $path (@{$self->paths}) {
      
      my $abs_path = Mojo::File->path(Array->merge_string([$path], $parts));
      
      if (Sys->r($abs_path->to_string)) {
        return $path;
      }
      
    }
    
    return undef;
  }

}

__END__

