# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojolicious::Static {
  version_from Mojolicious;
  
  use Mojo::Asset::File;
  use Mojo::Asset::Memory;
  use Mojo::Date;
  use Mojo::File;
  use Mojo::Util;
  use Mojolicious::Controller;
  
  # Fields
  has asset_dir : rw string;
  
  has classes : rw string[];
  
  has extra : rw Hash of string;
  
  has paths : rw string[];
  
  has prefix : rw string;
  
  # Undocumented Fields
  has assets : Hash;
  
  # Class Methods
  static method new : Mojolicious::Static () {
    
    my $self = new Mojolicious::Static;
    
    $self->{paths} = new string[0];
    
    $self->{asset_dir} = "assets";
    
    $self->{classes} = ["main"];
    
    $self->{extra} = Hash->new;
    
    return $self;
  }
  
  # Instance Methods
  method asset_path : string ($asset : string) {
    
    unless (Re->m($asset, "^\/")) {
      $asset = "/$asset";
    }
    
    $self->{assets} //= Hash->new;
    
    my $assets = $self->{assets};
    
    return $self->file_path("/" . $self->asset_dir . ($assets->{$asset}->(string) // $asset));
  }
  
  method file_path : string ($file : string) {
    
    unless (Re->m($file, "^\/")) {
      $file = "/$file";
    }
    
    my $prefix = $self->prefix;
    unless ($prefix) {
      return $file ;
    }
    
    return "$prefix$file";
  }
  
  method dispatch : void ($c : Mojolicious::Controller) {
    die "TODO";
  }
  
  method is_fresh : int ($c  : Mojolicious::Controller, $options : Hash|object[] = undef) {
    
    # TODO
    die "TODO";
    
=pod

    my ($self, $c, $options) = @_;

    my $res_headers = $c->res->headers;
    my ($last, $etag) = @$options{qw(last_modified etag)};
    $res_headers->last_modified(Mojo::Date->new($last)->to_string)       if $last;
    $res_headers->etag($etag = ($etag =~ m!^W/"! ? $etag : qq{"$etag"})) if $etag;

    # Unconditional
    my $req_headers = $c->req->headers;
    my $match       = $req_headers->if_none_match;
    return undef unless (my $since = $req_headers->if_modified_since) || $match;

    # If-None-Match
    $etag //= $res_headers->etag // '';
    return undef if $match && !grep { $_ eq $etag || "W/$_" eq $etag } map { trim($_) } split /,/, $match;

    # If-Modified-Since
    return !!$match unless ($last //= $res_headers->last_modified) && $since;
    return _epoch($last) <= (_epoch($since) // 0);

=cut

  }
}
