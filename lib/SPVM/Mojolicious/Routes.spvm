# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojolicious::Routes extends Mojolicious::Routes::Route {
  version_from Mojolicious;
  
  use Hash;
  use Mojo::Cache;
  use Mojo::DynamicMethods;
  use Mojo::Callback;
  use Regex;
  use Mojolicious::Controller;
  
  # Interfaces
  interface Mojo::DynamicMethods;
  
  # Fields
  has cache : rw Mojo::Cache;
  
  has shortcuts : rw Hash of Mojo::Callback;
  
  # Class Methods
  static method new : Mojolicious::Routes () {
    
    my $self = new Mojolicious::Routes;
    
    $self->init;
    
    return $self;
  }
  
  private static method _render : int ($c : Mojolicious::Controller) {
    
    my $stash = $c->stash;
    
    if ($c->rendered) {
      return 0;
    }
    
    my $rendered = $c->render_maybe(undef);
    
    unless ($rendered) {
      unless ($c->routed) {
        die "Route without dispatch and nothing to render";
      }
    }
  }
  
  # Instance Methods
  protected method init : void ($options : object[] = undef) {
    
    $self->SUPER::init;
    
    $self->{cache} = Mojo::Cache->new;
    
    $self->{shortcuts} = Hash->new;
  }
  
  method dynamic_methods : Hash of Hash of Mojo::Callback () {
    return $self->shortcuts;
  }
  
  method add_shortcut : void ($name : string, $cb : Mojo::Callback) {
    $self->shortcuts->set($name, $cb);
  }
  
  method call : object ($name : string, $arg1 : object = undef, $arg2 : object = undef, $arg3 : object = undef) {
    
    my $ret = $self->Mojo::DynamicMethods::call($name, $arg1, $arg2, $arg3);
    
    return $ret;
  }
  
  method continue : int ($c : Mojolicious::Controller) {
    
    my $match = $c->match;
    my $stack = $match->stack;
    my $position = $match->position;
    
    my $field = $stack->[$position];
    unless ($field) {
      return &_render($c);
    }
    
    # Merge captures into stash
    $c->set_captures($field->clone);
    
    my $continue = 0;
    my $last = !$stack->[++$position];
    if (my $cb = $field->{"cb"}->(Mojo::Callback)) {
      $continue = $self->_callback($c, $cb, $last);
    }
    
    $match->set_position($position);
    
    if ($last || $continue) {
      $self->continue($c);
    }
  }
  
  private method _callback : int ($c : Mojolicious::Controller, $cb : Mojo::Callback, $last : int) {
    
    if ($last) {
      $c->set_routed(1);
    }
    
    $c->log->trace("Routing to a callback");
    
    return&_action($c->app, $c, $cb, $last);
  }
  
  private static method _action : int ($app : Mojolicious, $c : Mojolicious::Controller, $cb : Mojo::Callback, $last : int) {
    die "TODO";
    # $self->plugins->emit_chain(around_action => @_);
  }
  
  method any : Mojolicious::Routes ($args : object...) {
    
    my $route = $self->SUPER::any($args);
    
    my $routes = Mojolicious::Routes->new;
    
    copy_fields $routes, $route, Mojolicious::Routes::Route;
    
    return $routes;
  }
  
  method delete : Mojolicious::Routes ($args : object...) {
    
    my $route = $self->SUPER::delete($args);
    
    my $routes = Mojolicious::Routes->new;
    
    copy_fields $routes, $route, Mojolicious::Routes::Route;
    
    return $routes;
  }
  
  method get : Mojolicious::Routes ($args : object...) {
    
    my $route = $self->SUPER::get($args);
    
    my $routes = Mojolicious::Routes->new;
    
    copy_fields $routes, $route, Mojolicious::Routes::Route;
    
    return $routes;
  }
  
  method options : Mojolicious::Routes ($args : object...) {
    
    my $route = $self->SUPER::options($args);
    
    my $routes = Mojolicious::Routes->new;
    
    copy_fields $routes, $route, Mojolicious::Routes::Route;
    
    return $routes;
  }
  
  method patch : Mojolicious::Routes ($args : object...) {
    
    my $route = $self->SUPER::patch($args);
    
    my $routes = Mojolicious::Routes->new;
    
    copy_fields $routes, $route, Mojolicious::Routes::Route;
    
    return $routes;
  }
  
  method post : Mojolicious::Routes ($args : object...) {
    
    my $route = $self->SUPER::post($args);
    
    my $routes = Mojolicious::Routes->new;
    
    copy_fields $routes, $route, Mojolicious::Routes::Route;
    
    return $routes;
  }
  
  method put : Mojolicious::Routes ($args : object...) {
    
    my $route = $self->SUPER::put($args);
    
    my $routes = Mojolicious::Routes->new;
    
    copy_fields $routes, $route, Mojolicious::Routes::Route;
    
    return $routes;
  }
  
  method under : Mojolicious::Routes ($args : object...) {
    
    my $route = $self->SUPER::under($args);
    
    my $routes = Mojolicious::Routes->new;
    
    copy_fields $routes, $route, Mojolicious::Routes::Route;
    
    return $routes;
  }
  
  method websocket : Mojolicious::Routes ($args : object...) {
    
    my $route = $self->SUPER::websocket($args);
    
    my $routes = Mojolicious::Routes->new;
    
    copy_fields $routes, $route, Mojolicious::Routes::Route;
    
    return $routes;
  }
  
  method dispatch : int ($c : Mojolicious::Controller) {
    
    $self->match($c);
    
    unless (@{$c->match->stack}) {
      return 0;
    }
    
    $self->continue($c);
    
    return 1;
  }
  
  method match : void ($c : Mojolicious::Controller) {
    
    my $req  = $c->req;
    my $path = $req->url->path->to_route;
    
    # Method (HEAD will be treated as GET)
    my $method = Fn->uc($req->method);
    if ($method eq "HEAD") {
      $method = "GET";
    }
    
    # Check cache
    my $ws = $c->tx->is_websocket ? 1 : 0;
    my $match = $c->match;
    $match->set_root($self);
    my $cache = $self->cache;
    if (my $result = $cache->get("$method:$path:$ws")) {
      $match->set_endpoint($result->{"endpoint"}->(Mojolicious::Routes::Route));
      $match->set_stack($result->{"stack"}->(Hash[]));
      return;
    }
    
    # Check routes
    $match->find(Hash->new({method => $method, path => $path, websocket => $ws}));
    
    my $endpoint = $match->endpoint;
    
    unless ($endpoint) {
      return;
    }
    
    $cache->set("$method:$path:$ws" => Hash->new({endpoint => $endpoint, stack => $match->stack}));
  }

}
