# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojolicious::Types {
  version_from Mojolicious;
  
  use Hash;
  use Mojolicious::Controller;
  
  # Fields
  has mapping : rw Hash of string[]
    get {
      
      unless (exists $self->{mapping}) {
        $self->{mapping} = Hash->new({
          appcache => ["text/cache-manifest"],
          atom     => ["application/atom+xml"],
          bin      => ["application/octet-stream"],
          css      => ["text/css"],
          gif      => ["image/gif"],
          gz       => ["application/x-gzip"],
          htm      => ["text/html"],
          html     => ["text/html;charset=UTF-8"],
          ico      => ["image/x-icon"],
          jpeg     => ["image/jpeg"],
          jpg      => ["image/jpeg"],
          js       => ["application/javascript"],
          json     => ["application/json;charset=UTF-8"],
          mp3      => ["audio/mpeg"],
          mp4      => ["video/mp4"],
          ogg      => ["audio/ogg"],
          ogv      => ["video/ogg"],
          pdf      => ["application/pdf"],
          png      => ["image/png"],
          rss      => ["application/rss+xml"],
          sse      => ["text/event-stream"],
          svg      => ["image/svg+xml"],
          ttf      => ["font/ttf"],
          txt      => ["text/plain;charset=UTF-8"],
          webm     => ["video/webm"],
          woff     => ["font/woff"],
          woff2    => ["font/woff2"],
          xml      => ["application/xml", "text/xml"],
          zip      => ["application/zip"]
        });
      }
      
      return $self->{mapping};
    }
  ;
  
  # Class Methods
  static method new : Mojolicious::Types () {
    
    my $self = new Mojolicious::Types;
    
    return $self;
  }
  
  # Instance Methods
  method content_type : void ($c : Mojolicious::Controller, $options : object[] = undef) {
    
    my $options_h = Hash->new($options);
    
    my $headers = $c->res->headers;
    
    if ($headers->content_type) {
      return;
    }
    
    my $file = $options_h->get_string("file");
    
    my $ext = $options_h->get_string("ext");
    
    my $type = $file ? $self->file_type($file) : $self->type($ext);
    
    $headers->set_content_type($type // "application/octet-stream");
  }
  
  method detect : void () {

=pod

    my ($self, $accept) = @_;
    
    # Extract and prioritize MIME types
    my %types;
    /^\s*([^,; ]+)(?:\s*\;\s*q\s*=\s*(\d+(?:\.\d+)?))?\s*$/i and $types{lc $1} = $2 // 1 for split /,/, $accept // "";
    my @detected = sort { $types{$b} <=> $types{$a} } sort keys %types;

    # Detect extensions from MIME types
    my %reverse;
    my $mapping = $self->mapping;
    for my $ext (sort keys %$mapping) {
      my @types = @{$mapping->{$ext}};
      push @{$reverse{$_}}, $ext for map { s/\;.*$//; lc $_ } @types;
    }
    
    return [map { @{$reverse{$_} // []} } @detected];

=cut

  }
  
  method file_type : string ($file : string) {
    return $self->type(Mojo::File->path($file)->extname);
  }
  
  method type : string ($ext : string) {
    
    my $lc_ext = Fn->lc($ext);
    
    my $type = $self->mapping->get($lc_ext)->(string[])->[0];
    
    return $type;
  }
  
  method set_type : string ($ext : string, $type : object of string|string[] = undef) {
    
    my $types = (string[])undef;
    if ($type isa string) {
      $types = [(string)$type];
    }
    elsif ($type isa string[]) {
      $types = (string[])$type;
    }
    else {
      die "\$type must be a string or a string[] object.";
    }
    
    my $lc_ext = Fn->lc($ext);
    
    $self->mapping->set($lc_ext => $types);
  }

}
