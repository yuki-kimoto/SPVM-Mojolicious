# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojolicious::Plugins extends Mojo::EventEmitter {
  version_from Mojolicious;
  
  use Mojo::Loader;
  
  # Fields
  has namespaces : rw string[]
    get {
      if (exists $self->{namespaces}) {
        $self->{namespaces} = ["Mojolicious::Plugin"];
      }
      
      return $self->{namespaces};
    }
  ;
  
  # Class Methods
  static method new : Mojolicious::Plugins () {
    
    my $self = new Mojolicious::Plugins;
    
    return $self;
  }
  
  # Instance Methods
  method emit_chain : object ($name : string, $arg1 : object = undef, $arg2 : object = undef, $arg3 : object = undef) {
    
    my $wrapper = (Mojo::EventEmitter::Callback)undef;
    
    my $subscribers = $self->subscribers($name);
    
    my $subscribers_length = @$subscribers;
    
    my $cb = (Mojo::EventEmitter::Callback)undef;
    for (my $i = $subscribers_length - 1; $i >= 0; $i--) {
      
      $cb = $subscribers->[$i];
      
      my $next = $wrapper;
      
      $wrapper = [$cb : Mojo::EventEmitter::Callback, $next : Mojo::EventEmitter::Callback, $arg1 : object, $arg2 : object, $arg3 : object] method : object () {
        $cb->($next, $arg1, $arg2, $arg3);
      };
    }
    
    if (!$wrapper) {
      return undef;
    }
    else {
      return $wrapper->($cb);
    }
    
  }
  
  

}

__END__

TODO

sub emit_hook {
  my $self = shift;
  for my $cb (@{$self->subscribers(shift)}) { $cb->(@_) }
  return $self;
}

sub emit_hook_reverse {
  my $self = shift;
  for my $cb (reverse @{$self->subscribers(shift)}) { $cb->(@_) }
  return $self;
}

sub load_plugin {
  my ($self, $name) = @_;

  # Try all namespaces and full module name
  my $suffix  = $name =~ /^[a-z]/ ? camelize $name : $name;
  my @classes = map {"${_}::$suffix"} @{$self->namespaces};
  for my $class (@classes, $name) { return $class->new if _load($class) }

  # Not found
  die qq{Plugin "$name" missing, maybe you need to install it?\n};
}

sub register_plugin { shift->load_plugin(shift)->register(shift, ref $_[0] ? $_[0] : {@_}) }

sub _load {
  my $module = shift;
  return $module->isa('Mojolicious::Plugin') unless my $e = load_class $module;
  ref $e ? die $e : return undef;
}

