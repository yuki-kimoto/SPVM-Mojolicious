# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojolicious::Plugins extends Mojo::EventEmitter {
  version_from Mojolicious;
  
  use Mojo::Loader;
  use Mojolicious;
  use Mojolicious::Plugin;
  use Native::MethodCall;
  
  # Fields
  has namespaces : rw string[]
    get {
      if (exists $self->{namespaces}) {
        $self->{namespaces} = ["Mojolicious::Plugin"];
      }
      
      return $self->{namespaces};
    }
  ;
  
  # Class Methods
  static method new : Mojolicious::Plugins () {
    
    my $self = new Mojolicious::Plugins;
    
    return $self;
  }
  
  private static method _load : void ($class_name : string) {
    
    Mojo::Loader->load_class($class_name);
  }

  # Instance Methods
  method emit_chain : object ($name : string, $arg1 : object = undef, $arg2 : object = undef, $arg3 : object = undef) {
    
    my $wrapper = (Mojo::Callback)undef;
    
    my $subscribers = $self->subscribers($name);
    
    my $subscribers_length = @$subscribers;
    
    my $cb = (Mojo::Callback)undef;
    for (my $i = $subscribers_length - 1; $i >= 0; $i--) {
      
      $cb = $subscribers->[$i];
      
      my $next = $wrapper;
      
      $wrapper = [$cb : Mojo::Callback, $next : Mojo::Callback, $arg1 : object, $arg2 : object, $arg3 : object] method : object () {
        $cb->($next, $arg1, $arg2, $arg3);
      };
    }
    
    if (!$wrapper) {
      return undef;
    }
    else {
      return $wrapper->(undef);
    }
    
  }
  
  method emit_hook : void ($name : string, $arg1 : object = undef, $arg2 : object = undef, $arg3 : object = undef) {
    
    my $subscribers = $self->subscribers($name);
    
    my $subscribers_length = @$subscribers;
    
    for (my $i = 0; $i < $subscribers_length; $i++) {
      
      my $cb = $subscribers->[$i];
      
      $cb->($self, $arg1, $arg2, $arg3);
    }
  }
  
  method emit_hook_reverse : void ($name : string, $arg1 : object = undef, $arg2 : object = undef, $arg3 : object = undef) {
    
    my $subscribers = $self->subscribers($name);
    
    my $subscribers_length = @$subscribers;
    
    for (my $i = $subscribers_length - 1; $i >= 0; $i--) {
      
      my $cb = $subscribers->[$i];
      
      $cb->($self, $arg1, $arg2, $arg3);
    }
  }
  
  method load_plugin : object ($name : string) {
    
    # Try all namespaces and full module name
    my $loaded_class_name = (string)undef;
    my $namespaces = $self->namespaces;
    for (my $i = 0; $i < @$namespaces; $i++) {
      
      my $namespace = $namespaces->[$i];
      
      my $full_name = "${namespace}::$name";
      
      eval { &_load($full_name); };
      
      unless ($@) {
        $loaded_class_name = $full_name;
        last;
      }
      
      eval { &_load($name); };
      
      unless ($@) {
        $loaded_class_name = $name;
        last;
      }
      
    }
    
    unless ($loaded_class_name) {
      die "Plugin '$name' missing, maybe you need to install it?";
    }
    
    my $object = Native::MethodCall->call_class_method($loaded_class_name, "new");
    
    return $object;
  }
  
  method register_plugin : void ($name : string, $app : Mojolicious, $options : object[] = undef) {
    $self->load_plugin($name)->(Mojolicious::Plugin)->register($app, $options);
  }
  
}
