# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojolicious::Plugins extends Mojo::EventEmitter {
  version_from Mojolicious;
}

__END__

TODO

use Mojo::Loader qw(load_class);
use Mojo::Util   qw(camelize);

has namespaces => sub { ['Mojolicious::Plugin'] };

sub emit_chain {
  my ($self, $name, @args) = @_;

  my $wrapper;
  for my $cb (reverse @{$self->subscribers($name)}) {
    my $next = $wrapper;
    $wrapper = sub { $cb->($next, @args) };
  }

  !$wrapper ? return : return $wrapper->();
}

sub emit_hook {
  my $self = shift;
  for my $cb (@{$self->subscribers(shift)}) { $cb->(@_) }
  return $self;
}

sub emit_hook_reverse {
  my $self = shift;
  for my $cb (reverse @{$self->subscribers(shift)}) { $cb->(@_) }
  return $self;
}

sub load_plugin {
  my ($self, $name) = @_;

  # Try all namespaces and full module name
  my $suffix  = $name =~ /^[a-z]/ ? camelize $name : $name;
  my @classes = map {"${_}::$suffix"} @{$self->namespaces};
  for my $class (@classes, $name) { return $class->new if _load($class) }

  # Not found
  die qq{Plugin "$name" missing, maybe you need to install it?\n};
}

sub register_plugin { shift->load_plugin(shift)->register(shift, ref $_[0] ? $_[0] : {@_}) }

sub _load {
  my $module = shift;
  return $module->isa('Mojolicious::Plugin') unless my $e = load_class $module;
  ref $e ? die $e : return undef;
}

