# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojolicious::Lite extends Mojolicious {
  
  use FindBin;
  use Re;
  use Mojo::File;
  
  version_from Mojolicious;
  
  # Fields
  has routes : rw Mojolicious::Routes;
  
  # Class Method
  static method new : Mojolicious::Lite () {
    
    my $home = FindBin->Bin;
    
    my $exe = FindBin->Script;
    
    my $moniker = Mojo::File->path($exe)->basename;
    
    Re->s(my $_ = [$moniker], "\.(pl|pm|t)$", "");
    $moniker = $_->[0];
    
    my $app = new Mojolicious::Lite;
    
    $app->set_moniker($moniker);
    
    my $routes = $app->routes;
    $routes->set_namespaces(new string[0]);
    
    $app->{routes} = $routes;
    
    return $app;
  }
  
  # Instance Methods
  method any : void ($arg1 : object = undef, $arg2 : object = undef, $arg3 : object = undef, $arg4 : object = undef) {
    
    my $routes = $self->routes;
    
    $routes->any($arg1, $arg2, $arg3, $arg4);
  }
  
}

__END__

sub import {

  # Initialize routes without namespaces
  my $routes = $app->routes->namespaces([]);
  $app->static->classes->[0] = $app->renderer->classes->[0] = $caller;

  # The Mojolicious::Lite DSL
  my $root = $routes;
  for my $name (qw(any get options patch post put websocket)) {
    monkey_patch $caller, $name, sub { $routes->$name(@_) }
  }
  monkey_patch($caller, $_, sub {$app}) for qw(new app);
  monkey_patch $caller, del   => sub { $routes->delete(@_) };
  monkey_patch $caller, group => sub (&) {
    (my $old, $root) = ($root, $routes);
    shift->();
    ($routes, $root) = ($root, $old);
  };
  monkey_patch $caller,
    helper => sub { $app->helper(@_) },
    hook   => sub { $app->hook(@_) },
    plugin => sub { $app->plugin(@_) },
    under  => sub { $routes = $root->under(@_) };

  # Make sure there's a default application for testing
  Mojo::UserAgent::Server->app($app) unless Mojo::UserAgent::Server->app;

  # Lite apps are strict!
  unshift @_, 'Mojo::Base', '-strict';
  goto &Mojo::Base::import;
}


