# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojolicious {
  version "0.022";
  
  use Mojo::Home;
  use Mojo::Loader;
  use Mojo::Log;
  use Mojo::Server;
  use Mojo::Util;
  use Mojolicious::Controller;
  use Mojolicious::Plugins;
  use Mojolicious::Renderer;
  use Mojolicious::Routes;
  use Mojolicious::Sessions;
  use Mojolicious::Static;
  use Mojolicious::Types;
  use Mojo::Transaction;
  use Sys;
  
  # Fields
  has home : rw Mojo::Home
    get {
      unless (exists $self->{home}) {
        my $home = Mojo::Home->new;
        $home->detect;
        $self->{home} = $home;
      }
      return $self->{home};
    }
  ;
  
  has log  : rw Mojo::Log
    get {
      unless (exists $self->{log}) {
        my $log = Mojo::Log->new;
        
        if (length (my $_ = Sys->env("SPVM_MOJO_LOG_LEVEL"))) {
          $log->set_level($_);
        }
        else {
          unless ($self->mode eq "development") {
            $log->set_level("info");
          }
        }
        
        return $self->{log} = $log;
      }
    }
  ;
  
  has mode : rw string
    get {
      unless (exists $self->{mode}) {
        if (length (my $_ = Sys->env("SPVM_MOJO_MODE"))) {
          $self->{mode} = $_;
        }
        else {
          $self->{mode} = "development";
        }
      }
      return $self->{mode};
    }
  ;
  
  has moniker : rw string;
  
  has max_request_size : rw int;
  
  has plugins : rw Mojolicious::Plugins
    get {
      unless (exists $self->{plugins}) {
        $self->{plugins} = Mojolicious::Plugins->new;
      }
      return $self->{plugins};
    }
  ;
  
  has renderer : rw Mojolicious::Renderer
    get {
      unless (exists $self->{renderer}) {
        $self->{renderer} = Mojolicious::Renderer->new;
      }
      return $self->{renderer};
    }
  ;
  
  has routes : rw Mojolicious::Routes
    get {
      unless (exists $self->{routes}) {
        $self->{routes} = Mojolicious::Routes->new;
      }
      return $self->{routes};
    }
  ;
  
  has secrets : rw string[]
    get {
      unless (exists $self->{secrets}) {
        # Warn developers about insecure default
        $self->log->trace("Your secret passphrase needs to be changed (see FAQ for more)");
        
        # Default to moniker
        return [$self->moniker];
      }
      return $self->{secrets};
    }
  ;
  
  has sessions : rw Mojolicious::Sessions
    get {
      unless (exists $self->{sessions}) {
        $self->{sessions} = Mojolicious::Sessions->new;
      }
      return $self->{sessions};
    }
  ;
  
  has static : rw Mojolicious::Static
    get {
      unless (exists $self->{static}) {
        $self->{static} = Mojolicious::Static->new;
      }
      return $self->{static};
    }
  ;
  
  has types : rw Mojolicious::Types
    get {
      unless (exists $self->{types}) {
        $self->{types} = Mojolicious::Types->new;
      }
      return $self->{types};
    }
  ;
  
  has config : rw Hash;
  
  has defaults : rw Hash;
  
  # Class Methods
  static method new : Mojolicious () {
    
    my $self = new Mojolicious;
    
    return $self;
  }
  
  # Instance Methods
  method build_controller : Mojolicious::Controller ($tx : Mojo::Transaction) {
    
    unless ($tx) {
      die "The transaction \$tx must be defined.";
    }
    
    # Build default controller
    my $defaults = $self->defaults;
    
    my $stash = $defaults->clone;
    
    my $c = Mojolicious::Controller->new;
    $c->set_app($self);
    $c->set_tx($tx);
    $c->set_stash($stash);
    
    return $c;
  }
  
}

__END__

sub dispatch {
  my ($self, $c) = @_;

  my $plugins = $self->plugins->emit_hook(before_dispatch => $c);

  my $stash = $c->stash;
  return if $stash->{'mojo.rendered'};

  # Try to find a static file
  my $tx = $c->tx;
  $self->static->dispatch($c) and $plugins->emit_hook(after_static => $c) unless $tx->res->code;

  # Start timer (ignore static files)
  $c->helpers->log->trace(sub {
    my $req    = $c->req;
    my $method = $req->method;
    my $path   = $req->url->path->to_abs_string;
    $c->helpers->timing->begin('mojo.timer');
    return qq{$method "$path"};
  }) unless $stash->{'mojo.static'};

  # Routes
  $plugins->emit_hook(before_routes => $c);
  $c->helpers->reply->not_found unless $tx->res->code || $self->routes->dispatch($c) || $tx->res->code;
}

sub handler {
  my $self = shift;

  # Dispatcher has to be last in the chain
  ++$self->{dispatch}
    and $self->hook(around_action   => \&_action)
    and $self->hook(around_dispatch => sub { $_[1]->app->dispatch($_[1]) })
    unless $self->{dispatch};

  # Process with chain
  my $c = $self->build_controller(@_);
  $self->plugins->emit_chain(around_dispatch => $c);

  # Delayed response
  $c->helpers->log->trace('Nothing has been rendered, expecting delayed response (see FAQ for more)')
    unless $c->stash->{'mojo.rendered'};
}

sub helper { shift->renderer->add_helper(@_) }

sub hook { shift->plugins->on(@_) }

sub new {
  my $self = shift->SUPER::new((ref $_[0] ? %{shift()} : @_), @Mojo::Server::ARGS_OVERRIDE);

  my $home = $self->home;
  push @{$self->renderer->paths}, $home->child('templates')->to_string;
  push @{$self->static->paths},   $home->child('public')->to_string;

  # Default to controller and application namespace
  my $controller = "@{[ref $self]}::Controller";
  my $r          = $self->preload_namespaces([$controller])->routes->namespaces([$controller, ref $self]);

  $self->plugin($_) for qw(HeaderCondition DefaultHelpers TagHelpers EPLRenderer EPRenderer);

  # Exception handling should be first in chain
  $self->hook(around_dispatch => \&_exception);

  $self->startup;
  $self->warmup;

  return $self;
}

sub plugin {
  my $self = shift;
  $self->plugins->register_plugin(shift, $self, @_);
}

sub server { $_[0]->plugins->emit_hook(before_server_start => @_[1, 0]) }

sub start {
  my $self = shift;
  $_->warmup for $self->static, $self->renderer;
  return $self->commands->run(@_ ? @_ : @ARGV);
}

sub startup { }

sub warmup { Mojo::Loader::load_classes $_ for @{shift->preload_namespaces} }

sub _action {
  my ($next, $c, $action, $last) = @_;
  my $val = $action->($c);
  $val->catch(sub { $c->helpers->reply->exception(shift) }) if Scalar::Util::blessed $val && $val->isa('Mojo::Promise');
  return $val;
}

sub _die { CORE::die ref $_[0] ? $_[0] : Mojo::Exception->new(shift)->trace }

sub _exception {
  my ($next, $c) = @_;
  local $SIG{__DIE__} = \&_die;
  $c->helpers->reply->exception($@) unless eval { $next->(); 1 };
}

