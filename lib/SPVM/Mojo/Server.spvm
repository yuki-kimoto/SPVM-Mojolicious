# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojo::Server extends Mojo::EventEmitter {
  version_from Mojolicious;
  
  use Mojo::File;
  use Mojo::Util;
  use Sys;
  use Re;
  use Mojo::Transaction;
  
  # Fields
  has app : rw Mojolicious;
  
  has reverse_proxy : rw byte
    get {
      unless (exists $self->{reverse_proxy}) {
        my $reverse_proxy = 0;
        if (length (my $_ = Sys->env("SPVM_MOJO_REVERSE_PROXY"))) {
          $reverse_proxy = (int)$_;
        }
        else {
          $reverse_proxy = !!@{$self->trusted_proxies};
        }
        
        $self->{reverse_proxy} = (byte)$reverse_proxy;
      }
      return $self->{reverse_proxy};
    }
  ;
  
  has trusted_proxies : rw string[]
    get {
      unless (exists $self->{trusted_proxies}) {
        $self->{trusted_proxies} = Re->split("\s*,\s*", length (my $_ = Sys->env("SPVM_MOJO_TRUSTED_PROXIES")) ? $_ : "");
      }
      return $self->{trusted_proxies};
    }
  ;
  
  # Class Methods
  static method new : Mojo::Server () {
    
    my $self = new Mojo::Server;
    
    $self->on(request => method : void ($server : Mojo::Server, $tx : Mojo::Transaction::HTTP)  { $server->app->handler($tx); });
    
    return $self;
  }
  
  # Instance Methods
  method build_app : Mojolicious ($app : Mojolicious) {
    
    $self->set_app($app);
  }
  
  method build_tx : Mojo::Transaction::HTTP () {
    
    my $tx = $self->app->build_tx;
    
    $tx->req->set_trusted_proxies(Array->merge_string($tx->req->trusted_proxies, $self->trusted_proxies));
    
    if ($self->reverse_proxy) {
      $tx->req->set_reverse_proxy(1) ;
    }
    
    return $tx;
  }
  
  method run : void () { die "Not implemented."; }
  
}

