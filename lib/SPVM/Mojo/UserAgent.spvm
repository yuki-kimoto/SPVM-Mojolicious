# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojo::UserAgent extends Mojo::EventEmitter {
  version_from Mojolicious;
  
  use Mojo::UserAgent::Proxy;
  use Mojo::UserAgent::CookieJar;
  use Mojo::Transaction;
  use Mojo::Transaction::HTTP;
  use Mojo::UserAgent::Transactor;
  use Sys;
  use IO::Socket::INET;
  use IO::Socket::UNIX;
  
  # Enumerations
  private enum {
    READ_BUFFER_SIZE = 4086,
  }
  
  # Class Variables
  our $DEBUG : ro byte;
  INIT {
    if (length(my $_ = Sys->env("SPVM_MOJO_CLIENT_DEBUG"))) {
      $DEBUG = (byte)$_;
    }
  }
  
  # Fields
  has max_response_size : rw int;
  
  has connect_timeout : rw double;
  
  has inactivity_timeout : rw double;
  
  has request_timeout : rw double;
  
  has max_connections : rw int;
  
  has key : rw string;
  
  has ca : rw string;
  
  has cert : rw string;
  
  has insecure : rw byte;
  
  has max_redirects : rw int;
  
  has socket_options : rw object[];
  
  has tls_options : rw object[];
  
  has transactor : rw Mojo::UserAgent::Transactor;
  
  has proxy : rw Mojo::UserAgent::Proxy;
  
  has cookie_jar : rw Mojo::UserAgent::CookieJar;
  
  has handle : IO::Socket;
  
  has keep_alive_sockets_list : List of object[]; # endpoint and socket pairs 
  
  # Class Methods
  static method new : Mojo::UserAgent () {
    
    my $self = new Mojo::UserAgent;
    
    $self->{max_response_size} = -1;
    
    $self->{connect_timeout} = length(my $_ = Sys->env("SPVM_MOJO_CONNECT_TIMEOUT")) ? (double)$_ : 0.0;
    
    $self->{inactivity_timeout} = length(my $_ = Sys->env("SPVM_MOJO_INACTIVITY_TIMEOUT")) ? (double)$_ : 0.0;
    
    $self->{request_timeout} = length(my $_ = Sys->env("SPVM_MOJO_REQUEST_TIMEOUT")) ? (double)$_ : 0.0;
    
    $self->{max_connections} = 5;
    
    $self->{key} = length(my $_ = Sys->env("SPVM_MOJO_KEY_FILE")) ? $_ : undef;
    
    $self->{ca} = length(my $_ = Sys->env("SPVM_MOJO_CA_FILE")) ? $_ : undef;
    
    $self->{cert} = length(my $_ = Sys->env("SPVM_CERT_FILE")) ? $_ : undef;
    
    $self->{proxy} = Mojo::UserAgent::Proxy->new;
    
    $self->{cookie_jar} = Mojo::UserAgent::CookieJar->new;
    
    $self->{insecure} = (byte)(length(my $_ = Sys->env("SPVM_MOJO_INSECURE")) ? (int)$_ : 0);
    
    $self->{max_redirects} = length(my $_ = Sys->env("SPVM_MOJO_MAX_REDIRECTS")) ? (int)$_ : 0;
    
    $self->{transactor} = Mojo::UserAgent::Transactor->new;
    
    $self->{keep_alive_sockets_list} = List->new(new object[0]);
    
    return $self;
  }
  
  # Instance Methods
  method get : Mojo::Transaction::HTTP ($url : object of string|Mojo::URL, $options : object[] = undef) {
    
    my $method = "GET";
    
    my $tx = $self->build_tx($method, $url, $options);
    
    $tx = $self->start($tx);
    
    return $tx;
  }
  
  method head : Mojo::Transaction::HTTP ($url : object of string|Mojo::URL, $options : object[] = undef) {
    
    my $method = "HEAD";
    
    my $tx = $self->build_tx($method, $url, $options);
    
    $tx = $self->start($tx);
    
    return $tx;
  }
  
  method delete : Mojo::Transaction::HTTP ($url : object of string|Mojo::URL, $options : object[] = undef) {
    
    my $method = "DELETE";
    
    my $tx = $self->build_tx($method, $url, $options);
    
    $tx = $self->start($tx);
    
    return $tx;
  }
  
  method options : Mojo::Transaction::HTTP ($url : object of string|Mojo::URL, $options : object[] = undef) {
    
    my $method = "OPTIONS";
    
    my $tx = $self->build_tx($method, $url, $options);
    
    $tx = $self->start($tx);
    
    return $tx;
  }
  
  method patch : Mojo::Transaction::HTTP ($url : object of string|Mojo::URL, $options : object[] = undef) {
    
    my $method = "PATCH";
    
    my $tx = $self->build_tx($method, $url, $options);
    
    $tx = $self->start($tx);
    
    return $tx;
  }
  
  method post : Mojo::Transaction::HTTP ($url : object of string|Mojo::URL, $options : object[] = undef) {
    
    my $method = "POST";
    
    my $tx = $self->build_tx($method, $url, $options);
    
    $tx = $self->start($tx);
    
    return $tx;
  }
  
  method put : Mojo::Transaction::HTTP ($url : object of string|Mojo::URL, $options : object[] = undef) {
    
    my $method = "PUT";
    
    my $tx = $self->build_tx($method, $url, $options);
    
    $tx = $self->start($tx);
    
    return $tx;
  }
  
  method build_tx : Mojo::Transaction::HTTP ($method : string, $url : object of string|Mojo::URL, $options : object[] = undef) {
    return $self->transactor->tx($method, $url, $options);
  }
  
  method start : Mojo::Transaction::HTTP ($tx : Mojo::Transaction::HTTP) {
    
    # Application server
    $self->emit(prepare => $tx);
    my $url = $tx->req->url;
    
    $self->proxy->prepare($tx);
    $self->cookie_jar->prepare($tx);
    
    my $max = $self->max_response_size;
    if ($max >= 0) {
      $tx->res->set_max_message_size($max);
    }
    $self->emit(start => $tx);
    
    my $req = $tx->req;
    
    $tx = $self->request($tx);
    
    return $tx;
  }
  
  private method request : Mojo::Transaction::HTTP ($tx : Mojo::Transaction::HTTP)  {
    
    my $method = $tx->req->method;
    
    my $url = $tx->req->url;
    
    my $options = (object[])undef;
    
    my $options_h = Hash->new($options);
    
    my $headers = (Mojo::Headers)$options_h->delete_or_default("headers", undef);
    
    my $request_timeout = $options_h->delete_or_default_double("request_timeout", $self->{request_timeout});
    
    for my $name (@{$options_h->keys}) {
      die "The \$name option is not available.";
    }
    
    unless ($headers) {
      $headers = Mojo::Headers->new;
    }
    
    $url->set_port(80);
    
    $tx = $self->connect($tx);
    
    $self->write_request($tx);
    
    $self->read_response($tx);
    
    $self->finish($tx);
    
    return $tx;
  }
  
  method connect : Mojo::Transaction::HTTP ($tx : Mojo::Transaction::HTTP)  {
    
    my $handle = (IO::Socket)undef;
    
    # Reuse connection
    {
      my $_ = $self->transactor->endpoint($tx);
      my $proto = (string)$_->[0];
      my $host = (string)$_->[1];
      my $port = (int)$_->[2];
      my $endpoint = "$proto:$host:$port";
      
      if ($handle = $self->_dequeue($endpoint)) {
        if (&DEBUG) {
          warn "-- Reusing connection ($proto://$host:$port)" ;
        }
        
        unless ($tx->connection) {
          $tx->set_kept_alive(1) ;
        }
        
        $self->_process($tx);
        
        return $tx;
      }
    }
    
    # CONNECT request to proxy required
    if (my $connect_tx = $self->_connect_proxy($tx)) {
      return $connect_tx;
    }
    
    my $t = $self->transactor;
    
    my $_ = $t->peer($tx);
    my $proto = (string)$_->[0];
    my $host = (string)$_->[1];
    my $port = (int)$_->[2];
    
    unless ($proto eq "http" || $proto eq "https" || $proto eq "http+unix") {
      die "Unsupported protocol: $proto";
    }
    
    my $options_h = Hash->new;
    $options_h->set(Timeout => $self->connect_timeout);
    
    if ($proto eq "http+unix") { $options_h->set(path => $host); }
    else {
      $options_h->set(address => $host);
      $options_h->set(port => $port);
    }
    $options_h->set(socket_options => $self->socket_options);

=pod TODO

    # SOCKS
    if ($proto eq "socks") {
      $options_h->set(socks_address => $options_h->get_string("address"));
      $options_h->set(socks_port => $options_h->get_int("socks_port"));
      
      my $_ = $t->endpoint($tx);
      my $proto = (string)$_->[0];
      my $host = (string)$_->[1];
      my $port = (int)$_->[2];
      
      $options_h->set(address => $host);
      $options_h->set(port => $port);
      
      my $tx_req = $tx->req;
      $tx_req->set_via_proxy(0);
      my $userinfo = $tx_req->proxy->userinf;
      
      if ($userinfo) {
        my $_ = Fn->split(":", $userinfo);
        my $socks_user = $_->[0];
        my $socks_pass = $_->[1];
        
        $options_h->set(socks_user => $socks_user);
        $options_h->set(socks_pass => $socks_pass);
      }
    }

=cut

    # TLS
    my $tls = $proto eq "https";
    
    my $path = $options_h->get_string("path");
    
    # UNIX domain socket
    if ($path) {
      $options_h->set(Peer => $path);
      
      $handle = (IO::Socket)IO::Socket::UNIX->new($options_h->to_array);
    }
    
    # IP socket
    else {
      $options_h->set(PeerAddr => $options_h->get_string("socks_address") // $options_h->get_string("address"));
      $options_h->delete("socks_address");
      $options_h->delete("address");
      $options_h->set(PeerPort => &_port($options_h));
      $options_h->delete("socks_port");
      $options_h->delete("port");
      
      my $socket_options = (object[])$options_h->get("socket_options");
      if ($socket_options) {
        for (my $i = 0; $i < @$socket_options; $i += 2) {
          my $key = (string)$socket_options->[$i];
          my $value = $socket_options->[$i + 1];
          $options_h->set($key => $value);
        }
      }
      $options_h->delete("socket_options");
      
      if ($tls) {
        $options_h->set(tls => $tls);
        $options_h->set(tls_ca => $self->ca);
        $options_h->set(tls_cert => $self->cert);
        $options_h->set(tls_key => $self->key);
        
        $options_h->set(tls_options => $self->tls_options);
        if ($self->insecure) {
          my $tls_options = (object[])$options_h->get("tls_options") // new object[0];;
          $tls_options = Fn->merge_options($tls_options, [(object)0x00]);
          $options_h->set(tls_options => $tls_options);
        }
        
        if (require IO::Socket::SSL) {
          $handle = (IO::Socket)IO::Socket::SSL->new($options_h->to_array);
        }
        else {
          die "IO::Socket::SSL is not installed.";
        }
      }
      else {
        $handle = (IO::Socket)IO::Socket::IP->new($options_h->to_array);
      }
    }
    
    $self->{handle} = $handle;
    
    if (&DEBUG) {
      warn "-- Connect ($proto://$host:$port)";
    }
    
    return $tx;
  }
  
  private method write_request : void ($tx : Mojo::Transaction::HTTP) {
    
    my $req = $tx->req;
    
    my $socket = $self->{handle};
    
    my $start_line = $req->build_start_line;
    
    $socket->write($start_line);
    
    my $header_lines = $req->build_headers;
    
    $socket->write($header_lines);
    
    $socket->write("\r\n");
  }
  
  private method read_response : void ($tx : Mojo::Transaction::HTTP) {
    
    my $res = Mojo::Message::Response->new;
    
    my $handle = $self->{handle};
    
    while (1) {
      my $chunk = (mutable string)new_string_len &READ_BUFFER_SIZE;
      
      my $read_length = $handle->read($chunk);
      
      if ($read_length == 0) {
        $res->finish;
        last;
      }
      
      Fn->shorten($chunk, $read_length);
      
      $res->parse($chunk);
      
      if ($res->is_finished) {
        last;
      }
    }
    
    $tx->set_res($res);
  }
  
  private method _redirect : void ($old : Mojo::Transaction::HTTP) {
    
    my $new = $self->transactor->redirect($old);
    
    unless ($new) {
      return;
    }
    
    unless (@{$old->redirects} < $self->max_redirects) {
      return;
    }
    
    $self->start($new);
  }
  
  method finish : void ($tx : Mojo::Transaction) {
    
    # Premature connection close
    $tx->closed;
    my $res = $tx->res;
    $res->finish;
    
    if ($res->code == 0) {
      die "Premature connection close.";
    }
    
    if ($tx->is_websocket) {
      my $_ = $self->transactor->endpoint($tx);
      my $proto = (string)$_->[0];
      my $host = (string)$_->[1];
      my $port = (int)$_->[2];
      my $endpoint = "$proto:$host:$port";
      
      $self->_dequeue($endpoint);
      return;
    }
    else {
      my $tx_ = (Mojo::Transaction::HTTP)$tx;
      
      $self->cookie_jar->collect($tx_);
      
      # Upgrade connection to WebSocket
      if (my $ws_tx = $self->transactor->upgrade($tx_)) {
        $ws_tx->client_read($tx_->res->content->leftovers);
        return;
      }
      
      # CONNECT requests always have a follow-up request
      unless (Fn->uc($tx_->req->method) eq "CONNECT") {
        $self->_reuse($tx_) ;
      }
      
      $self->_redirect($tx_);
    }
  }
  
  method _reuse : void ($tx : Mojo::Transaction::HTTP) {
    
    # Connection close
    my $max = $self->max_connections;
    
    # Keep connection alive
    my $keep_alive_sockets_list = $self->{keep_alive_sockets_list};
    
    while ($keep_alive_sockets_list->length && $keep_alive_sockets_list->length >= $max) {
      $keep_alive_sockets_list->shift;
    }
    
    my $_ = $self->transactor->endpoint($tx);
    my $proto = (string)$_->[0];
    my $host = (string)$_->[1];
    my $port = (int)$_->[2];
    my $endpoint = "$proto:$host:$port";
    
    $keep_alive_sockets_list->push([(object)$endpoint, $tx->handle]);
  }
  
  method _connect_proxy : Mojo::Transaction::HTTP ($old : Mojo::Transaction::HTTP) {
    
    # Start CONNECT request
    my $new = $self->transactor->proxy_connect($old);
    
    unless ($new) {
      return undef;
    }
    
    my $tx = $self->start($new);
    
    # Real transaction
    $old->set_previous($tx);
    $old->req->set_via_proxy(0);
    
    # CONNECT failed
    if (!$tx->res->is_success || !$tx->keep_alive) {
      die "Proxy connection failed.";
    }
    
    # Start real transaction without TLS upgrade
    unless ($tx->req->url->protocol eq "https") {
      $self->_process($tx);
      return $tx;
    }
    
    # TLS upgrade before starting the real transaction
    $tx = $self->connect($old);
    
    return $tx;
  }
  
  method _process : void ($tx : Mojo::Transaction::HTTP) {
    
    my $handle = $tx->handle;
    
    unless ($handle isa IO::Socket::UNIX) {
      my $handle_ip = (IO::Socket::IP)$handle;
      $tx->set_local_address($handle_ip->sockhost);
      $tx->set_local_port($handle_ip->sockport);
      $tx->set_remote_address($handle_ip->peerhost);
      $tx->set_remote_port($handle_ip->peerport);
    }
  }
  
  static method _port : int ($options_h : Hash) {
    
    my $port = 0;
    
    if ($options_h->exists("socks_port")) {
      $port = $options_h->get_int("socks_port");
    }
    elsif ($options_h->exists("port")) {
      $port = $options_h->get_int("port");
    }
    else {
      my $tsl = $options_h->get_or_default_int("tls", 0);
      $port = $tsl ? 443 : 80;
    }
    
    return $port;
  }
  
  method _dequeue : IO::Socket ($endpoint : string)  {
    
    my $keep_alive_sockets_list = $self->{keep_alive_sockets_list};
    
    for (my $i = 0; $i < $keep_alive_sockets_list->length; $i++) {
      my $keep_alive_socket = (object[])$keep_alive_sockets_list->get($i);
      my $my_endpoint = (string)$keep_alive_socket->[0];
      my $handle = (IO::Socket)$keep_alive_socket->[1];
      
      if ($endpoint eq $my_endpoint) {
        $keep_alive_sockets_list->remove($i);
        return $handle;
      }
    }
    
    return undef;
  }
  
  private static method SSL_cert_default : string () {
    
    my $SSL_cert_default = <<'EOS';
-----BEGIN CERTIFICATE-----
MIIEpDCCAowCCQD2f63fTFHflTANBgkqhkiG9w0BAQsFADAUMRIwEAYDVQQDDAls
b2NhbGhvc3QwHhcNMTkwNjI4MjExNDI5WhcNMzkwNjIzMjExNDI5WjAUMRIwEAYD
VQQDDAlsb2NhbGhvc3QwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC2
lW4DOBswU1YJkekNF6c4b1VVcpOvtqsLHhTxUz538bffcvhI2vv+aCltG6g5mlvJ
wo5NEu9l0ZG5TD9Ca4+WOOisVWrAI/i2YxXFQLOdjhKRBB1BvrOxSaFOuCXz9+cj
VRo0R8Dq3k+1aSy93Yf+fq9pL7LFJaUOlxcU2FOM+HW9FYPeVbqCzYqpPJoaBnwN
tQkQg7i8ufbeMS0bCcFpfTSV4pCgpWg1L9z6cVmBHtxc4MQv7rTTal+BF/iZDfDk
qTNFJpuK7IGtSVB5laTcssYKGuY5QhN5BBPoGEMP3f0KiZmgMOUqwR6fMUiidacG
iSIcgy05uOJyZ4oroqOzesz8nm2jH1eRPys2WLLFd801GKOZZE2LvNhCVzNIE0s1
Rr8yyWBU9jbjQuxlTAtyMUKKOqG9qsfEnKOsl9T9/pFcpJjad3spwhQSWhWEPWca
avw0CGVaGQ3nYmr9aJ9vpGBIiIsLQOPTzpOOPCDauMFpAPOoKnvIu+iz3Z8sUrMu
Ld+aT/3yxpAtNkmVv5A951XyFt9WDXF7jZOMHdOSZPvvI/Yn7joJUzfP9d7TLKjz
Xu+dzQnrAN3xuAXuy+jBpMIl3OPzwER6a8v7gUKRA/achNlIeOOmBdNn1cyHddcn
k6wiaXHJlFsl8X6IjCs9ILwv6H+ZGq/5QNU1Nrv5kQIDAQABMA0GCSqGSIb3DQEB
CwUAA4ICAQCo3xjINrsIQYvpVwVLpcO1p+oE5NV0ipA30JT+89Dn+vCejel9NzxT
msuD9aQSiNaB4znlIDqux4bSKkcRXDGINiaGNIDNXOtO/787LXjUZlljPVVHoPWi
hxgwc0nUHz3l/YvoXMKHI8blPkIhXl7xgKSuKQu05evjd//kpdHs1h+7b2vtCB0/
VoYTX/NrIX5oMYCvHkZEypQbDJ3VeAkOhRJ4efGEuEskPRm0+eDSL7elas/65saZ
l8vgkKDHZ9K0pd8JXc7EKmg3OBS22C5Lfhhy8AgqMa6R9p54oE4rH4yFaTe3BzFL
xSA6HWqC987L2OCFr2LJ8hZpawDF1otukGHDou/5+4Q03EZz10RuZfzlCLO5DXzW
Q28AtcCxz40n9o1giWzEj4LSYW4qsrpr5cNIhCqMzGPwp2OyS/TazPNJGoT8WKFU
Kr+Y/prfkXAwgVkXlUSiu7ukiYslSM4BbYWHDxd75Iv4GzzhUirSuJKN95RglxR8
XsJFlQwZ/tLvpflqb1Z8gPIV/4avtF+ybdx1AvqYViBQDf6GmLkM3p6Nwfj1LnCn
kFhnqY80gyVjbZXvp9ClypExzgz55/o2ZIijznCaDkFSVBdv+aUIzl98IicZxHqP
WREB+GMKmkaYrfKqlliQKdkXd2mXP/N8rv7SJEzHHpGRKBXsIAalrA==
-----END CERTIFICATE-----
EOS
    
  }
  
  private static method SSL_key_default : string () {
    
    my $SSL_key_default = <<'EOS';
-----BEGIN PRIVATE KEY-----
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
0N/URKPaZ8Z9V/c15kNhIZBgJhOoVg==
-----END PRIVATE KEY-----
EOS
    
    return $SSL_key_default;
  }
}

__END__

package Mojo::UserAgent;
use Mojo::Base 'Mojo::EventEmitter';

# "Fry: Since when is the Internet about robbing people of their privacy?
#  Bender: August 6, 1991."
use Mojo::IOLoop;
use Mojo::Promise;
use Mojo::Util qw(monkey_patch term_escape);
use Mojo::UserAgent::CookieJar;
use Mojo::UserAgent::Proxy;
use Mojo::UserAgent::Server;
use Mojo::UserAgent::Transactor;
use Scalar::Util qw(weaken);

use constant DEBUG => $ENV{MOJO_CLIENT_DEBUG} || 0;

has ca                 => sub { $ENV{MOJO_CA_FILE} };
has cert               => sub { $ENV{MOJO_CERT_FILE} };
has connect_timeout    => sub { $ENV{MOJO_CONNECT_TIMEOUT} || 10 };
has cookie_jar         => sub { Mojo::UserAgent::CookieJar->new };
has inactivity_timeout => sub { $ENV{MOJO_INACTIVITY_TIMEOUT} // 40 };
has insecure           => sub { $ENV{MOJO_INSECURE} };
has 'max_response_size';
has ioloop                           => sub { Mojo::IOLoop->new };
has key                              => sub { $ENV{MOJO_KEY_FILE} };
has max_connections                  => 5;
has max_redirects                    => sub { $ENV{MOJO_MAX_REDIRECTS} || 0 };
has proxy                            => sub { Mojo::UserAgent::Proxy->new };
has request_timeout                  => sub { $ENV{MOJO_REQUEST_TIMEOUT} // 0 };
has server                           => sub { Mojo::UserAgent::Server->new(ioloop => shift->ioloop) };
has [qw(socket_options tls_options)] => sub { {} };
has transactor                       => sub { Mojo::UserAgent::Transactor->new };

# Common HTTP methods
for my $name (qw(DELETE GET HEAD OPTIONS PATCH POST PUT)) {
  monkey_patch __PACKAGE__, lc $name, sub {
    my ($self, $cb) = (shift, ref $_[-1] eq 'CODE' ? pop : undef);
    return $self->start($self->build_tx($name, @_), $cb);
  };
  monkey_patch __PACKAGE__, lc($name) . '_p', sub {
    my $self = shift;
    return $self->start_p($self->build_tx($name, @_));
  };
}

sub DESTROY { shift->_cleanup unless ${^GLOBAL_PHASE} eq 'DESTRUCT' }

sub build_tx           { shift->transactor->tx(@_) }
sub build_websocket_tx { shift->transactor->websocket(@_) }

sub start {
  my ($self, $tx, $cb) = @_;

  # Fork-safety
  $self->_cleanup->server->restart if $self->{pid} && $self->{pid} ne $$;
  $self->{pid} //= $$;

  # Non-blocking
  if ($cb) {
    warn "-- Non-blocking request (@{[_url($tx)]})\n" if DEBUG;
    return $self->_start(Mojo::IOLoop->singleton, $tx, $cb);
  }

  # Blocking
  warn "-- Blocking request (@{[_url($tx)]})\n" if DEBUG;
  $self->_start($self->ioloop, $tx => sub { shift->ioloop->stop; $tx = shift });
  $self->ioloop->start;

  return $tx;
}

sub start_p {
  my ($self, $tx) = @_;
  my $promise = Mojo::Promise->new;
  $self->start($tx => sub { shift->transactor->promisify($promise, shift) });
  return $promise;
}

sub websocket {
  my ($self, $cb) = (shift, pop);
  $self->start($self->build_websocket_tx(@_), $cb);
}

sub websocket_p {
  my $self = shift;
  return $self->start_p($self->build_websocket_tx(@_));
}

sub _cleanup {
  my $self = shift;
  delete $self->{pid};
  $self->_finish($_, 1) for keys %{$self->{connections} // {}};
  return $self;
}

sub _connect {
  my ($self, $loop, $tx, $handle) = @_;

  my $t = $self->transactor;
  my ($proto, $host, $port) = $handle ? $t->endpoint($tx) : $t->peer($tx);

  my %options = (timeout => $self->connect_timeout);
  if   ($proto eq 'http+unix') { $options{path}             = $host }
  else                         { @options{qw(address port)} = ($host, $port) }
  $options{socket_options} = $self->socket_options;
  $options{handle}         = $handle if $handle;

  # SOCKS
  if ($proto eq 'socks') {
    @options{qw(socks_address socks_port)} = @options{qw(address port)};
    ($proto, @options{qw(address port)}) = $t->endpoint($tx);
    my $userinfo = $tx->req->via_proxy(0)->proxy->userinfo;
    @options{qw(socks_user socks_pass)} = split /:/, $userinfo if $userinfo;
  }

  # TLS
  if ($options{tls} = $proto eq 'https') {
    map { $options{"tls_$_"} = $self->$_ } qw(ca cert key);
    $options{tls_options} = $self->tls_options;
    $options{tls_options}{SSL_verify_mode} = 0x00 if $self->insecure;
  }

  weaken $self;
  my $id;
  return $id = $loop->client(
    %options => sub {
      my ($loop, $err, $stream) = @_;

      # Connection error
      return unless $self;
      return $self->_error($id, $err) if $err;

      # Connection established
      $stream->on(timeout => sub { $self->_error($id, 'Inactivity timeout') });
      $stream->on(close   => sub { $self && $self->_finish($id, 1) });
      $stream->on(error   => sub { $self && $self->_error($id, pop) });
      $stream->on(read    => sub { $self->_read($id, pop) });
      $self->_process($id);
    }
  );
}

sub _connect_proxy {
  my ($self, $loop, $old, $cb) = @_;

  # Start CONNECT request
  return undef unless my $new = $self->transactor->proxy_connect($old);
  my $id;
  return $id = $self->_start(
    ($loop, $new) => sub {
      my ($self, $tx) = @_;

      # Real transaction
      $old->previous($tx)->req->via_proxy(0);
      my $c = $self->{connections}{$id} = {cb => $cb, ioloop => $loop, tx => $old};

      # CONNECT failed
      return $self->_error($id, 'Proxy connection failed') if $tx->error || !$tx->res->is_success || !$tx->keep_alive;

      # Start real transaction without TLS upgrade
      return $self->_process($id) unless $tx->req->url->protocol eq 'https';

      # TLS upgrade before starting the real transaction
      my $handle = $loop->stream($id)->steal_handle;
      $self->_remove($id);
      $id = $self->_connect($loop, $old, $handle);
      $self->{connections}{$id} = $c;
    }
  );
}

sub _connection {
  my ($self, $loop, $tx, $cb) = @_;

  # Reuse connection
  my ($proto, $host, $port) = $self->transactor->endpoint($tx);
  my $id;
  if ($id = $self->_dequeue($loop, "$proto:$host:$port")) {
    warn "-- Reusing connection $id ($proto://$host:$port)\n" if DEBUG;
    @{$self->{connections}{$id}}{qw(cb tx)} = ($cb, $tx);
    $tx->kept_alive(1) unless $tx->connection;
    $self->_process($id);
    return $id;
  }

  # CONNECT request to proxy required
  if (my $id = $self->_connect_proxy($loop, $tx, $cb)) { return $id }

  # New connection
  $tx->res->error({message => "Unsupported protocol: $proto"}) and return $loop->next_tick(sub { $self->$cb($tx) })
    unless $proto eq 'http' || $proto eq 'https' || $proto eq 'http+unix';
  $id = $self->_connect($loop, $tx);
  warn "-- Connect $id ($proto://$host:$port)\n" if DEBUG;
  $self->{connections}{$id} = {cb => $cb, ioloop => $loop, tx => $tx};

  return $id;
}

sub _dequeue {
  my ($self, $loop, $name, $test) = @_;

  my $old = $self->{queue}{$loop} //= [];
  my ($found, @new);
  for my $queued (@$old) {
    push @new, $queued and next if $found || !grep { $_ eq $name } @$queued;
    
    # Search for id/name and sort out corrupted connections if necessary
    next unless my $stream = $loop->stream($queued->[1]);
    $stream->is_readable ? $stream->close : ($found = $queued->[1]);
  }
  @$old = @new;
  
  return $found;
}

sub _error {
  my ($self, $id, $err) = @_;
  my $tx = $self->{connections}{$id}{tx};
  $tx->res->error({message => $err}) if $tx;
  $self->_finish($id, 1);
}

sub _finish {
  my ($self, $id, $close) = @_;

  # Remove request timeout and finish transaction
  return undef unless my $c = $self->{connections}{$id};
  $c->{ioloop}->remove(delete $c->{timeout}) if $c->{timeout};
  return $self->_reuse($id, $close) unless my $old = $c->{tx};

  # Premature connection close
  my $res = $old->closed->res->finish;
  $res->error({message => 'Premature connection close'}) if $close && !$res->code && !$res->error;

  # Always remove connection for WebSockets
  return $self->_remove($id) if $old->is_websocket;
  $self->cookie_jar->collect($old);

  # Upgrade connection to WebSocket
  if (my $new = $self->transactor->upgrade($old)) {
    weaken $self;
    $new->on(resume => sub { $self->_write($id) });
    $c->{cb}($self, $c->{tx} = $new);
    return $new->client_read($old->res->content->leftovers);
  }

  # CONNECT requests always have a follow-up request
  $self->_reuse($id, $close) unless uc $old->req->method eq 'CONNECT';
  $res->error({message => $res->message, code => $res->code}) if $res->is_error;
  $c->{cb}($self, $old) unless $self->_redirect($c, $old);
}

sub _process {
  my ($self, $id) = @_;

  my $c      = $self->{connections}{$id};
  my $stream = $c->{ioloop}->stream($id)->timeout($self->inactivity_timeout);
  my $tx     = $c->{tx}->connection($id);
  my $handle = $stream->handle;
  unless ($handle->isa('IO::Socket::UNIX')) {
    $tx->local_address($handle->sockhost)->local_port($handle->sockport);
    $tx->remote_address($handle->peerhost)->remote_port($handle->peerport);
  }

  weaken $self;
  $tx->on(resume => sub { $self->_write($id) });
  $self->_write($id);
}

sub _read {
  my ($self, $id, $chunk) = @_;

  # Corrupted connection
  return $self->_remove($id) unless my $tx = $self->{connections}{$id}{tx};
  warn term_escape "-- Client <<< Server (@{[_url($tx)]})\n$chunk\n" if DEBUG;
  $tx->client_read($chunk);
  $self->_finish($id) if $tx->is_finished;
}

sub _redirect {
  my ($self, $c, $old) = @_;
  return undef unless my $new = $self->transactor->redirect($old);
  return undef unless @{$old->redirects} < $self->max_redirects;
  return $self->_start($c->{ioloop}, $new, delete $c->{cb});
}

sub _remove {
  my ($self, $id) = @_;
  my $c = delete $self->{connections}{$id};
  return unless $c->{ioloop};
  $self->_dequeue($c->{ioloop}, $id);
  $c->{ioloop}->remove($id);
}

sub _reuse {
  my ($self, $id, $close) = @_;

  # Connection close
  my $c   = $self->{connections}{$id};
  my $tx  = delete $c->{tx};
  my $max = $self->max_connections;
  return $self->_remove($id) if $close || !$tx || !$max || !$tx->keep_alive || $tx->error;

  # Keep connection alive
  my $queue = $self->{queue}{$c->{ioloop}} //= [];
  $self->_remove(shift(@$queue)->[1]) while @$queue && @$queue >= $max;
  push @$queue, [join(':', $self->transactor->endpoint($tx)), $id];
}

sub _start {
  my ($self, $loop, $tx, $cb) = @_;

  # Application server
  $self->emit(prepare => $tx);
  my $url = $tx->req->url;
  if (!$url->is_abs && (my $server = $self->server)) {
    my $base = $loop == $self->ioloop ? $server->url : $server->nb_url;
    $url->scheme($base->scheme)->host($base->host)->port($base->port);
  }

  $_->prepare($tx) for $self->proxy, $self->cookie_jar;
  my $max = $self->max_response_size;
  $tx->res->max_message_size($max) if defined $max;
  $self->emit(start => $tx);

  # Allow test servers sharing the same event loop to clean up connections
  !$loop->next_tick(sub { }) and $loop->one_tick unless $loop->is_running;
  return undef                                   unless my $id = $self->_connection($loop, $tx, $cb);

  if (my $t = $self->request_timeout) {
    weaken $self;
    $self->{connections}{$id}{timeout} ||= $loop->timer($t => sub { $self->_error($id, 'Request timeout') });
  }

  return $id;
}

sub _url { shift->req->url->to_abs }

sub _write {
  my ($self, $id) = @_;

  # Protect from resume event recursion
  my $c = $self->{connections}{$id};
  return if !(my $tx = $c->{tx}) || $c->{writing};
  local $c->{writing} = 1;
  my $chunk = $tx->client_write;
  warn term_escape "-- Client >>> Server (@{[_url($tx)]})\n$chunk\n" if DEBUG;
  return unless length $chunk;

  weaken $self;
  $c->{ioloop}->stream($id)->write($chunk => sub { $self && $self->_write($id) });
}

1;

=encoding utf8

=head1 NAME

Mojo::UserAgent - Non-blocking I/O HTTP and WebSocket user agent

=head1 SYNOPSIS

  use Mojo::UserAgent;

  # Fine grained response handling (dies on connection errors)
  my $ua  = Mojo::UserAgent->new;
  my $res = $ua->get('docs.mojolicious.org')->result;
  if    ($res->is_success)  { say $res->body }
  elsif ($res->is_error)    { say $res->message }
  elsif ($res->code == 301) { say $res->headers->location }
  else                      { say 'Whatever...' }

  # Say hello to the Unicode snowman and include an Accept header
  say $ua->get('www.☃.net?hello=there' => {Accept => '*/*'})->result->body;

  # Extract data from HTML and XML resources with CSS selectors
  say $ua->get('www.perl.org')->result->dom->at('title')->text;

  # Scrape the latest headlines from a news site
  say $ua->get('blogs.perl.org')->result->dom->find('h2 > a')->map('text')->join("\n");

  # IPv6 PUT request with Content-Type header and content
  my $tx = $ua->put('[::1]:3000' => {'Content-Type' => 'text/plain'} => 'Hi!');

  # Quick JSON API request with Basic authentication
  my $url = Mojo::URL->new('https://example.com/test.json')->userinfo('sri:☃');
  my $value = $ua->get($url)->result->json;

  # JSON POST (application/json) with TLS certificate authentication
  my $tx = $ua->cert('tls.crt')->key('tls.key')->post('https://example.com' => json => {top => 'secret'});

  # Form POST (application/x-www-form-urlencoded)
  my $tx = $ua->post('https://metacpan.org/search' => form => {q => 'mojo'});

  # Search DuckDuckGo anonymously through Tor
  $ua->proxy->http('socks://127.0.0.1:9050');
  say $ua->get('api.3g2upl4pq6kufc4m.onion/?q=mojolicious&format=json')->result->json('/Abstract');

  # GET request via UNIX domain socket "/tmp/myapp.sock" (percent encoded slash)
  say $ua->get('http+unix://%2Ftmp%2Fmyapp.sock/test')->result->body;

  # Follow redirects to download Mojolicious from GitHub
  $ua->max_redirects(5)
    ->get('https://www.github.com/mojolicious/mojo/tarball/main')
    ->result->save_to('/home/sri/mojo.tar.gz');

  # Non-blocking request
  $ua->get('mojolicious.org' => sub ($ua, $tx) { say $tx->result->dom->at('title')->text });
  Mojo::IOLoop->start unless Mojo::IOLoop->is_running;

  # Concurrent non-blocking requests (synchronized with promises)
  my $mojo_promise = $ua->get_p('mojolicious.org');
  my $cpan_promise = $ua->get_p('cpan.org');
  Mojo::Promise->all($mojo_promise, $cpan_promise)->then(sub ($mojo, $cpan) {
    say $mojo->[0]->result->dom->at('title')->text;
    say $cpan->[0]->result->dom->at('title')->text;
  })->wait;

  # WebSocket connection sending and receiving JSON via UNIX domain socket
  $ua->websocket('ws+unix://%2Ftmp%2Fmyapp.sock/echo.json' => sub ($ua, $tx) {
    say 'WebSocket handshake failed!' and return unless $tx->is_websocket;
    $tx->on(json => sub ($tx, $hash) {
      say "WebSocket message via JSON: $hash->{msg}";
      $tx->finish;
    });
    $tx->send({json => {msg => 'Hello World!'}});
  });
  Mojo::IOLoop->start unless Mojo::IOLoop->is_running;

=head1 DESCRIPTION

L<Mojo::UserAgent> is a full featured non-blocking I/O HTTP and WebSocket user agent, with IPv6, TLS, SNI, IDNA,
HTTP/SOCKS5 proxy, UNIX domain socket, Comet (long polling), Promises/A+, keep-alive, connection pooling, timeout,
cookie, multipart, gzip compression and multiple event loop support.

All connections will be reset automatically if a new process has been forked, this allows multiple processes to share
the same L<Mojo::UserAgent> object safely.

For better scalability (epoll, kqueue) and to provide non-blocking name resolution, SOCKS5 as well as TLS support, the
optional modules L<EV> (4.32+), L<Net::DNS::Native> (0.15+), L<IO::Socket::Socks> (0.64+) and L<IO::Socket::SSL>
(2.009+) will be used automatically if possible. Individual features can also be disabled with the C<MOJO_NO_NNR>,
C<MOJO_NO_SOCKS> and C<MOJO_NO_TLS> environment variables.

See L<Mojolicious::Guides::Cookbook/"USER AGENT"> for more.

=head1 EVENTS

L<Mojo::UserAgent> inherits all events from L<Mojo::EventEmitter> and can emit the following new ones.

=head2 prepare

  $ua->on(prepare => sub ($ua, $tx) {...});

Emitted whenever a new transaction is being prepared, before relative URLs are rewritten and cookies added. This
includes automatically prepared proxy C<CONNECT> requests and followed redirects.

  $ua->on(prepare => sub ($ua, $tx) {
    $tx->req->url(Mojo::URL->new('/mock-mojolicious')) if $tx->req->url->host eq 'mojolicious.org';
  });

=head2 start

  $ua->on(start => sub ($ua, $tx) {...});

Emitted whenever a new transaction is about to start. This includes automatically prepared proxy C<CONNECT> requests
and followed redirects.

  $ua->on(start => sub ($ua, $tx) {
    $tx->req->headers->header('X-Bender' => 'Bite my shiny metal ass!');
  });

=head1 ATTRIBUTES

L<Mojo::UserAgent> implements the following attributes.

=head2 ca

  my $ca = $ua->ca;
  $ua    = $ua->ca('/etc/tls/ca.crt');

Path to TLS certificate authority file used to verify the peer certificate, defaults to the value of the
C<MOJO_CA_FILE> environment variable.

  # Show certificate authorities for debugging
  IO::Socket::SSL::set_defaults(SSL_verify_callback => sub { say "Authority: $_[2]" and return $_[0] });

=head2 cert

  my $cert = $ua->cert;
  $ua      = $ua->cert('/etc/tls/client.crt');

Path to TLS certificate file, defaults to the value of the C<MOJO_CERT_FILE> environment variable.

=head2 connect_timeout

  my $timeout = $ua->connect_timeout;
  $ua         = $ua->connect_timeout(5);

Maximum amount of time in seconds establishing a connection may take before getting canceled, defaults to the value of
the C<MOJO_CONNECT_TIMEOUT> environment variable or C<10>.

=head2 cookie_jar

  my $cookie_jar = $ua->cookie_jar;
  $ua            = $ua->cookie_jar(Mojo::UserAgent::CookieJar->new);

Cookie jar to use for requests performed by this user agent, defaults to a L<Mojo::UserAgent::CookieJar> object.

  # Ignore all cookies
  $ua->cookie_jar->ignore(sub { 1 });

  # Ignore cookies for public suffixes
  my $ps = IO::Socket::SSL::PublicSuffix->default;
  $ua->cookie_jar->ignore(sub ($cookie) {
    return undef unless my $domain = $cookie->domain;
    return ($ps->public_suffix($domain))[0] eq '';
  });

  # Add custom cookie to the jar
  $ua->cookie_jar->add(
    Mojo::Cookie::Response->new(
      name   => 'foo',
      value  => 'bar',
      domain => 'docs.mojolicious.org',
      path   => '/Mojolicious'
    )
  );

=head2 inactivity_timeout

  my $timeout = $ua->inactivity_timeout;
  $ua         = $ua->inactivity_timeout(15);

Maximum amount of time in seconds a connection can be inactive before getting closed, defaults to the value of the
C<MOJO_INACTIVITY_TIMEOUT> environment variable or C<40>. Setting the value to C<0> will allow connections to be
inactive indefinitely.

=head2 insecure

  my $bool = $ua->insecure;
  $ua      = $ua->insecure($bool);

Do not require a valid TLS certificate to access HTTPS/WSS sites, defaults to the value of the C<MOJO_INSECURE>
environment variable.

  # Disable TLS certificate verification for testing
  say $ua->insecure(1)->get('https://127.0.0.1:3000')->result->code;

=head2 ioloop

  my $loop = $ua->ioloop;
  $ua      = $ua->ioloop(Mojo::IOLoop->new);

Event loop object to use for blocking I/O operations, defaults to a L<Mojo::IOLoop> object.

=head2 key

  my $key = $ua->key;
  $ua     = $ua->key('/etc/tls/client.crt');

Path to TLS key file, defaults to the value of the C<MOJO_KEY_FILE> environment variable.

=head2 max_connections

  my $max = $ua->max_connections;
  $ua     = $ua->max_connections(5);

Maximum number of keep-alive connections that the user agent will retain before it starts closing the oldest ones,
defaults to C<5>. Setting the value to C<0> will prevent any connections from being kept alive.

=head2 max_redirects

  my $max = $ua->max_redirects;
  $ua     = $ua->max_redirects(3);

Maximum number of redirects the user agent will follow before it fails, defaults to the value of the
C<MOJO_MAX_REDIRECTS> environment variable or C<0>.

=head2 max_response_size

  my $max = $ua->max_response_size;
  $ua     = $ua->max_response_size(16777216);

Maximum response size in bytes, defaults to the value of L<Mojo::Message::Response/"max_message_size">. Setting the
value to C<0> will allow responses of indefinite size. Note that increasing this value can also drastically increase
memory usage, should you for example attempt to parse an excessively large response body with the methods
L<Mojo::Message/"dom"> or L<Mojo::Message/"json">.

=head2 proxy

  my $proxy = $ua->proxy;
  $ua       = $ua->proxy(Mojo::UserAgent::Proxy->new);

Proxy manager, defaults to a L<Mojo::UserAgent::Proxy> object.

  # Detect proxy servers from environment
  $ua->proxy->detect;

  # Manually configure HTTP proxy (using CONNECT for HTTPS/WebSockets)
  $ua->proxy->http('http://127.0.0.1:8080')->https('http://127.0.0.1:8080');

  # Manually configure Tor (SOCKS5)
  $ua->proxy->http('socks://127.0.0.1:9050')->https('socks://127.0.0.1:9050');

  # Manually configure UNIX domain socket (using CONNECT for HTTPS/WebSockets)
  $ua->proxy->http('http+unix://%2Ftmp%2Fproxy.sock') ->https('http+unix://%2Ftmp%2Fproxy.sock');

=head2 request_timeout

  my $timeout = $ua->request_timeout;
  $ua         = $ua->request_timeout(5);

Maximum amount of time in seconds establishing a connection, sending the request and receiving a whole response may
take before getting canceled, defaults to the value of the C<MOJO_REQUEST_TIMEOUT> environment variable or C<0>.
Setting the value to C<0> will allow the user agent to wait indefinitely. The timeout will reset for every followed
redirect.

  # Total limit of 5 seconds, of which 3 seconds may be spent connecting
  $ua->max_redirects(0)->connect_timeout(3)->request_timeout(5);

=head2 server

  my $server = $ua->server;
  $ua        = $ua->server(Mojo::UserAgent::Server->new);

Application server relative URLs will be processed with, defaults to a L<Mojo::UserAgent::Server> object.

  # Mock web service
  $ua->server->app(Mojolicious->new);
  $ua->server->app->routes->get('/time' => sub ($c) {
    $c->render(json => {now => time});
  });
  my $time = $ua->get('/time')->result->json->{now};

  # Change log level
  $ua->server->app->log->level('fatal');

  # Port currently used for processing relative URLs blocking
  say $ua->server->url->port;

  # Port currently used for processing relative URLs non-blocking
  say $ua->server->nb_url->port;

=head2 socket_options

  my $options = $ua->socket_options;
  $ua         = $ua->socket_options({LocalAddr => '127.0.0.1'});

Additional options for L<IO::Socket::IP> when opening new connections.

=head2 tls_options

  my $options = $ua->tls_options;
  $ua         = $ua->tls_options({SSL_cipher_list => 'DEFAULT:!DH@SECLEVEL=1'});

Additional options for L<IO::Socket::SSL> when opening new connections.

=head2 transactor

  my $t = $ua->transactor;
  $ua   = $ua->transactor(Mojo::UserAgent::Transactor->new);

Transaction builder, defaults to a L<Mojo::UserAgent::Transactor> object.

  # Change name of user agent
  $ua->transactor->name('MyUA 1.0');

  # Disable compression
  $ua->transactor->compressed(0);

=head1 METHODS

L<Mojo::UserAgent> inherits all methods from L<Mojo::EventEmitter> and implements the following new ones.

=head2 build_tx

  my $tx = $ua->build_tx(GET => 'example.com');
  my $tx = $ua->build_tx(PUT => 'http://example.com' => {Accept => '*/*'} => 'Content!');
  my $tx = $ua->build_tx(PUT => 'http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
  my $tx = $ua->build_tx(PUT => 'http://example.com' => {Accept => '*/*'} => json => {a => 'b'});

Generate L<Mojo::Transaction::HTTP> object with L<Mojo::UserAgent::Transactor/"tx">.

  # Request with custom cookie
  my $tx = $ua->build_tx(GET => 'https://example.com/account');
  $tx->req->cookies({name => 'user', value => 'sri'});
  $tx = $ua->start($tx);

  # Deactivate gzip compression
  my $tx = $ua->build_tx(GET => 'example.com');
  $tx->req->headers->remove('Accept-Encoding');
  $tx = $ua->start($tx);

  # Interrupt response by raising an error
  my $tx = $ua->build_tx(GET => 'http://example.com');
  $tx->res->on(progress => sub ($res) {
    return unless my $server = $res->headers->server;
    $res->error({message => 'Oh noes, it is IIS!'}) if $server =~ /IIS/;
  });
  $tx = $ua->start($tx);

=head2 build_websocket_tx

  my $tx = $ua->build_websocket_tx('ws://example.com');
  my $tx = $ua->build_websocket_tx( 'ws://example.com' => {DNT => 1} => ['v1.proto']);

Generate L<Mojo::Transaction::HTTP> object with L<Mojo::UserAgent::Transactor/"websocket">.

  # Custom WebSocket handshake with cookie
  my $tx = $ua->build_websocket_tx('wss://example.com/echo');
  $tx->req->cookies({name => 'user', value => 'sri'});
  $ua->start($tx => sub ($ua, $tx) {
    say 'WebSocket handshake failed!' and return unless $tx->is_websocket;
    $tx->on(message => sub ($tx, $msg) {
      say "WebSocket message: $msg";
      $tx->finish;
    });
    $tx->send('Hi!');
  });
  Mojo::IOLoop->start unless Mojo::IOLoop->is_running;

=head2 delete

  my $tx = $ua->delete('example.com');
  my $tx = $ua->delete('http://example.com' => {Accept => '*/*'} => 'Content!');
  my $tx = $ua->delete('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
  my $tx = $ua->delete('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});

Perform blocking C<DELETE> request and return resulting L<Mojo::Transaction::HTTP> object, takes the same arguments as
L<Mojo::UserAgent::Transactor/"tx"> (except for the C<DELETE> method, which is implied). You can also append a callback
to perform requests non-blocking.

  $ua->delete('http://example.com' => json => {a => 'b'} => sub ($ua, $tx) { say $tx->result->body });
  Mojo::IOLoop->start unless Mojo::IOLoop->is_running;

=head2 delete_p

  my $promise = $ua->delete_p('http://example.com');

Same as L</"delete">, but performs all requests non-blocking and returns a L<Mojo::Promise> object instead of accepting
a callback.

  $ua->delete_p('http://example.com' => json => {a => 'b'})->then(sub ($tx) {
    say $tx->result->body;
  })->catch(sub ($err) {
    warn "Connection error: $err";
  })->wait;

=head2 get

  my $tx = $ua->get('example.com');
  my $tx = $ua->get('http://example.com' => {Accept => '*/*'} => 'Content!');
  my $tx = $ua->get('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
  my $tx = $ua->get('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});

Perform blocking C<GET> request and return resulting L<Mojo::Transaction::HTTP> object, takes the same arguments as
L<Mojo::UserAgent::Transactor/"tx"> (except for the C<GET> method, which is implied). You can also append a callback to
perform requests non-blocking.

  $ua->get('http://example.com' => json => {a => 'b'} => sub ($ua, $tx) { say $tx->result->body });
  Mojo::IOLoop->start unless Mojo::IOLoop->is_running;

=head2 get_p

  my $promise = $ua->get_p('http://example.com');

Same as L</"get">, but performs all requests non-blocking and returns a L<Mojo::Promise> object instead of accepting a
callback.

  $ua->get_p('http://example.com' => json => {a => 'b'})->then(sub ($tx) {
    say $tx->result->body;
  })->catch(sub ($err) {
    warn "Connection error: $err";
  })->wait;

=head2 head

  my $tx = $ua->head('example.com');
  my $tx = $ua->head('http://example.com' => {Accept => '*/*'} => 'Content!');
  my $tx = $ua->head('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
  my $tx = $ua->head('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});

Perform blocking C<HEAD> request and return resulting L<Mojo::Transaction::HTTP> object, takes the same arguments as
L<Mojo::UserAgent::Transactor/"tx"> (except for the C<HEAD> method, which is implied). You can also append a callback
to perform requests non-blocking.

  $ua->head('http://example.com' => json => {a => 'b'} => sub ($ua, $tx) { say $tx->result->body });
  Mojo::IOLoop->start unless Mojo::IOLoop->is_running;

=head2 head_p

  my $promise = $ua->head_p('http://example.com');

Same as L</"head">, but performs all requests non-blocking and returns a L<Mojo::Promise> object instead of accepting a
callback.

  $ua->head_p('http://example.com' => json => {a => 'b'})->then(sub ($tx) {
    say $tx->result->body;
  })->catch(sub ($err) {
    warn "Connection error: $err";
  })->wait;

=head2 options

  my $tx = $ua->options('example.com');
  my $tx = $ua->options('http://example.com' => {Accept => '*/*'} => 'Content!');
  my $tx = $ua->options('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
  my $tx = $ua->options('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});

Perform blocking C<OPTIONS> request and return resulting L<Mojo::Transaction::HTTP> object, takes the same arguments as
L<Mojo::UserAgent::Transactor/"tx"> (except for the C<OPTIONS> method, which is implied). You can also append a
callback to perform requests non-blocking.

  $ua->options('http://example.com' => json => {a => 'b'} => sub ($ua, $tx) { say $tx->result->body });
  Mojo::IOLoop->start unless Mojo::IOLoop->is_running;

=head2 options_p

  my $promise = $ua->options_p('http://example.com');

Same as L</"options">, but performs all requests non-blocking and returns a L<Mojo::Promise> object instead of
accepting a callback.

  $ua->options_p('http://example.com' => json => {a => 'b'})->then(sub ($tx) {
    say $tx->result->body;
  })->catch(sub ($err) {
    warn "Connection error: $err";
  })->wait;

=head2 patch

  my $tx = $ua->patch('example.com');
  my $tx = $ua->patch('http://example.com' => {Accept => '*/*'} => 'Content!');
  my $tx = $ua->patch('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
  my $tx = $ua->patch('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});

Perform blocking C<PATCH> request and return resulting L<Mojo::Transaction::HTTP> object, takes the same arguments as
L<Mojo::UserAgent::Transactor/"tx"> (except for the C<PATCH> method, which is implied). You can also append a callback
to perform requests non-blocking.

  $ua->patch('http://example.com' => json => {a => 'b'} => sub ($ua, $tx) { say $tx->result->body });
  Mojo::IOLoop->start unless Mojo::IOLoop->is_running;

=head2 patch_p

  my $promise = $ua->patch_p('http://example.com');

Same as L</"patch">, but performs all requests non-blocking and returns a L<Mojo::Promise> object instead of accepting
a callback.

  $ua->patch_p('http://example.com' => json => {a => 'b'})->then(sub ($tx) {
    say $tx->result->body;
  })->catch(sub ($err) {
    warn "Connection error: $err";
  })->wait;

=head2 post

  my $tx = $ua->post('example.com');
  my $tx = $ua->post('http://example.com' => {Accept => '*/*'} => 'Content!');
  my $tx = $ua->post('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
  my $tx = $ua->post('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});

Perform blocking C<POST> request and return resulting L<Mojo::Transaction::HTTP> object, takes the same arguments as
L<Mojo::UserAgent::Transactor/"tx"> (except for the C<POST> method, which is implied). You can also append a callback
to perform requests non-blocking.

  $ua->post('http://example.com' => json => {a => 'b'} => sub ($ua, $tx) { say $tx->result->body });
  Mojo::IOLoop->start unless Mojo::IOLoop->is_running;

=head2 post_p

  my $promise = $ua->post_p('http://example.com');

Same as L</"post">, but performs all requests non-blocking and returns a L<Mojo::Promise> object instead of accepting a
callback.

  $ua->post_p('http://example.com' => json => {a => 'b'})->then(sub ($tx) {
    say $tx->result->body;
  })->catch(sub ($err) {
    warn "Connection error: $err";
  })->wait;

=head2 put

  my $tx = $ua->put('example.com');
  my $tx = $ua->put('http://example.com' => {Accept => '*/*'} => 'Content!');
  my $tx = $ua->put('http://example.com' => {Accept => '*/*'} => form => {a => 'b'});
  my $tx = $ua->put('http://example.com' => {Accept => '*/*'} => json => {a => 'b'});

Perform blocking C<PUT> request and return resulting L<Mojo::Transaction::HTTP> object, takes the same arguments as
L<Mojo::UserAgent::Transactor/"tx"> (except for the C<PUT> method, which is implied). You can also append a callback to
perform requests non-blocking.

  $ua->put('http://example.com' => json => {a => 'b'} => sub ($ua, $tx) { say $tx->result->body });
  Mojo::IOLoop->start unless Mojo::IOLoop->is_running;

=head2 put_p

  my $promise = $ua->put_p('http://example.com');

Same as L</"put">, but performs all requests non-blocking and returns a L<Mojo::Promise> object instead of accepting a
callback.

  $ua->put_p('http://example.com' => json => {a => 'b'})->then(sub ($tx) {
    say $tx->result->body;
  })->catch(sub ($err) {
    warn "Connection error: $err";
  })->wait;

=head2 start

  my $tx = $ua->start(Mojo::Transaction::HTTP->new);

Perform blocking request for a custom L<Mojo::Transaction::HTTP> object, which can be prepared manually or with
L</"build_tx">. You can also append a callback to perform requests non-blocking.

  my $tx = $ua->build_tx(GET => 'http://example.com');
  $ua->start($tx => sub ($ua, $tx) { say $tx->result->body });
  Mojo::IOLoop->start unless Mojo::IOLoop->is_running;

=head2 start_p

  my $promise = $ua->start_p(Mojo::Transaction::HTTP->new);

Same as L</"start">, but performs all requests non-blocking and returns a L<Mojo::Promise> object instead of accepting
a callback.

  my $tx = $ua->build_tx(GET => 'http://example.com');
  $ua->start_p($tx)->then(sub ($tx) {
    say $tx->result->body;
  })->catch(sub ($err) {
    warn "Connection error: $err";
  })->wait;

=head2 websocket

  $ua->websocket('ws://example.com' => sub {...});
  $ua->websocket('ws://example.com' => {DNT => 1} => ['v1.proto'] => sub {...});

Open a non-blocking WebSocket connection with transparent handshake, takes the same arguments as
L<Mojo::UserAgent::Transactor/"websocket">. The callback will receive either a L<Mojo::Transaction::WebSocket> or
L<Mojo::Transaction::HTTP> object, depending on if the handshake was successful.

  $ua->websocket('wss://example.com/echo' => ['v1.proto'] => sub ($ua, $tx) {
    say 'WebSocket handshake failed!' and return unless $tx->is_websocket;
    say 'Subprotocol negotiation failed!' and return unless $tx->protocol;
    $tx->on(finish => sub ($tx, $code, $reason) { say "WebSocket closed with status $code." });
    $tx->on(message => sub ($tx, $msg) {
      say "WebSocket message: $msg";
      $tx->finish;
    });
    $tx->send('Hi!');
  });
  Mojo::IOLoop->start unless Mojo::IOLoop->is_running;

You can activate C<permessage-deflate> compression by setting the C<Sec-WebSocket-Extensions> header, this can result
in much better performance, but also increases memory usage by up to 300KiB per connection.

  $ua->websocket('ws://example.com/foo' => {
    'Sec-WebSocket-Extensions' => 'permessage-deflate'
  } => sub {...});

=head2 websocket_p

  my $promise = $ua->websocket_p('ws://example.com');

Same as L</"websocket">, but returns a L<Mojo::Promise> object instead of accepting a callback.

  $ua->websocket_p('wss://example.com/echo')->then(sub ($tx) {
    my $promise = Mojo::Promise->new;
    $tx->on(finish => sub { $promise->resolve });
    $tx->on(message => sub ($tx, $msg) {
      say "WebSocket message: $msg";
      $tx->finish;
    });
    $tx->send('Hi!');
    return $promise;
  })->catch(sub ($err) {
    warn "WebSocket error: $err";
  })->wait;

=head1 DEBUGGING

You can set the C<MOJO_CLIENT_DEBUG> environment variable to get some advanced diagnostics information printed to
C<STDERR>.

  MOJO_CLIENT_DEBUG=1

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut









package Mojo::IOLoop::Client;
use Mojo::Base 'Mojo::EventEmitter';

use Errno qw(EINPROGRESS);
use IO::Socket::IP;
use IO::Socket::UNIX;
use Mojo::IOLoop;
use Mojo::IOLoop::TLS;
use Scalar::Util qw(weaken);
use Socket       qw(IPPROTO_TCP SOCK_STREAM TCP_NODELAY);

# Non-blocking name resolution requires Net::DNS::Native
use constant NNR => $ENV{MOJO_NO_NNR} ? 0 : !!eval { require Net::DNS::Native; Net::DNS::Native->VERSION('0.15'); 1 };
my $NDN;

# SOCKS support requires IO::Socket::Socks
use constant SOCKS => $ENV{MOJO_NO_SOCKS}
  ? 0
  : !!eval { require IO::Socket::Socks; IO::Socket::Socks->VERSION('0.64'); 1 };
use constant READ  => SOCKS ? IO::Socket::Socks::SOCKS_WANT_READ()  : 0;
use constant WRITE => SOCKS ? IO::Socket::Socks::SOCKS_WANT_WRITE() : 0;

has reactor => sub { Mojo::IOLoop->singleton->reactor }, weak => 1;

sub DESTROY { shift->_cleanup }

sub can_nnr   {NNR}
sub can_socks {SOCKS}

sub connect {
  my ($self, $args) = (shift, ref $_[0] ? $_[0] : {@_});

  # Timeout
  weaken $self;
  my $reactor = $self->reactor;
  $self->{timer} = $reactor->timer($args->{timeout} || 10, sub { $self->emit(error => 'Connect timeout') });

  # Blocking name resolution
  $_ && s/[[\]]//g for @$args{qw(address socks_address)};
  my $address = $args->{socks_address} || ($args->{address} ||= '127.0.0.1');
  return $reactor->next_tick(sub { $self && $self->_connect($args) }) if !NNR || $args->{handle} || $args->{path};

  # Non-blocking name resolution
  $NDN //= Net::DNS::Native->new(pool => 5, extra_thread => 1);
  my $handle = $self->{dns}
    = $NDN->getaddrinfo($address, _port($args), {protocol => IPPROTO_TCP, socktype => SOCK_STREAM});
  $reactor->io(
    $handle => sub {
      my $reactor = shift;

      $reactor->remove($self->{dns});
      my ($err, @res) = $NDN->get_result(delete $self->{dns});
      return $self->emit(error => "Can't resolve: $err") if $err;

      $args->{addr_info} = \@res;
      $self->_connect($args);
    }
  )->watch($handle, 1, 0);
}

sub _cleanup {
  my $self = shift;
  $NDN->timedout($self->{dns}) if $NDN && $self->{dns};
  return $self unless my $reactor = $self->reactor;
  $self->{$_} && $reactor->remove(delete $self->{$_}) for qw(dns timer handle);
  return $self;
}

sub _connect {
  my ($self, $args) = @_;

  my $path   = $args->{path};
  my $handle = $self->{handle} = $args->{handle};

  unless ($handle) {
    my $class   = $path ? 'IO::Socket::UNIX' : 'IO::Socket::IP';
    my %options = (Blocking => 0);

    # UNIX domain socket
    if ($path) { $options{Peer} = $path }

    # IP socket
    else {
      if (my $info = $args->{addr_info}) { $options{PeerAddrInfo} = $info }
      else {
        $options{PeerAddr} = $args->{socks_address} || $args->{address};
        $options{PeerPort} = _port($args);
      }
      @options{keys %{$args->{socket_options}}} = values %{$args->{socket_options}} if $args->{socket_options};
    }

    return $self->emit(error => "Can't connect: $@") unless $self->{handle} = $handle = $class->new(%options);
  }
  $handle->blocking(0);

  $path ? $self->_try_socks($args) : $self->_wait('_ready', $handle, $args);
}

sub _port { $_[0]{socks_port} || $_[0]{port} || ($_[0]{tls} ? 443 : 80) }

sub _ready {
  my ($self, $args) = @_;

  # Socket changes in between attempts and needs to be re-added for epoll/kqueue
  my $handle = $self->{handle};
  unless ($handle->connect) {
    return $self->emit(error => $!) unless $! == EINPROGRESS;
    $self->reactor->remove($handle);
    return $self->_wait('_ready', $handle, $args);
  }

  return $self->emit(error => $! || 'Not connected') unless $handle->connected;

  # Disable Nagle's algorithm
  setsockopt $handle, IPPROTO_TCP, TCP_NODELAY, 1;

  $self->_try_socks($args);
}

sub _socks {
  my ($self, $args) = @_;

  # Connected
  my $handle = $self->{handle};
  return $self->_try_tls($args) if $handle->ready;

  # Switch between reading and writing
  my $err = $IO::Socket::Socks::SOCKS_ERROR;
  if    ($err == READ)  { $self->reactor->watch($handle, 1, 0) }
  elsif ($err == WRITE) { $self->reactor->watch($handle, 1, 1) }
  else                  { $self->emit(error => $err) }
}

sub _try_socks {
  my ($self, $args) = @_;

  my $handle = $self->{handle};
  return $self->_try_tls($args)                                                     unless $args->{socks_address};
  return $self->emit(error => 'IO::Socket::Socks 0.64+ required for SOCKS support') unless SOCKS;

  my %options = (ConnectAddr => $args->{address}, ConnectPort => $args->{port});
  @options{qw(AuthType Username Password)} = ('userpass', @$args{qw(socks_user socks_pass)}) if $args->{socks_user};
  my $reactor = $self->reactor;
  $reactor->remove($handle);
  return $self->emit(error => 'SOCKS upgrade failed') unless IO::Socket::Socks->start_SOCKS($handle, %options);

  $self->_wait('_socks', $handle, $args);
}

sub _try_tls {
  my ($self, $args) = @_;

  my $handle = $self->{handle};
  return $self->_cleanup->emit(connect => $handle) unless $args->{tls};
  my $reactor = $self->reactor;
  $reactor->remove($handle);

  # Start TLS handshake
  weaken $self;
  my $tls = Mojo::IOLoop::TLS->new($handle)->reactor($self->reactor);
  $tls->on(upgrade => sub { $self->_cleanup->emit(connect => pop) });
  $tls->on(error   => sub { $self->emit(error => pop) });
  $tls->negotiate(%$args);
}

sub _wait {
  my ($self, $next, $handle, $args) = @_;
  weaken $self;
  $self->reactor->io($handle => sub { $self->$next($args) })->watch($handle, 0, 1);
}

1;

=encoding utf8

=head1 NAME

Mojo::IOLoop::Client - Non-blocking TCP/IP and UNIX domain socket client

=head1 SYNOPSIS

  use Mojo::IOLoop::Client;

  # Create socket connection
  my $client = Mojo::IOLoop::Client->new;
  $client->on(connect => sub ($client, $handle) {...});
  $client->on(error => sub ($client, $err) {...});
  $client->connect(address => 'example.com', port => 80);

  # Start reactor if necessary
  $client->reactor->start unless $client->reactor->is_running;

=head1 DESCRIPTION

L<Mojo::IOLoop::Client> opens TCP/IP and UNIX domain socket connections for L<Mojo::IOLoop>.

=head1 EVENTS

L<Mojo::IOLoop::Client> inherits all events from L<Mojo::EventEmitter> and can emit the following new ones.

=head2 connect

  $client->on(connect => sub ($client, $handle) {...});

Emitted once the connection is established.

=head2 error

  $client->on(error => sub ($client, $err) {...});

Emitted if an error occurs on the connection, fatal if unhandled.

=head1 ATTRIBUTES

L<Mojo::IOLoop::Client> implements the following attributes.

=head2 reactor

  my $reactor = $client->reactor;
  $client     = $client->reactor(Mojo::Reactor::Poll->new);

Low-level event reactor, defaults to the C<reactor> attribute value of the global L<Mojo::IOLoop> singleton. Note that
this attribute is weakened.

=head1 METHODS

L<Mojo::IOLoop::Client> inherits all methods from L<Mojo::EventEmitter> and implements the following new ones.

=head2 can_nnr

  my $bool = Mojo::IOLoop::Client->can_nnr;

True if L<Net::DNS::Native> 0.15+ is installed and non-blocking name resolution support enabled.

=head2 can_socks

  my $bool = Mojo::IOLoop::Client->can_socks;

True if L<IO::Socket::SOCKS> 0.64+ is installed and SOCKS5 support enabled.

=head2 connect

  $client->connect(address => '127.0.0.1', port => 3000);
  $client->connect({address => '127.0.0.1', port => 3000});

Open a socket connection to a remote host. Note that non-blocking name resolution depends on L<Net::DNS::Native>
(0.15+), SOCKS5 support on L<IO::Socket::Socks> (0.64), and TLS support on L<IO::Socket::SSL> (2.009+).

These options are currently available:

=over 2

=item address

  address => 'mojolicious.org'

Address or host name of the peer to connect to, defaults to C<127.0.0.1>.

=item handle

  handle => $handle

Use an already prepared L<IO::Socket::IP> object.

=item path

  path => '/tmp/myapp.sock'

Path of UNIX domain socket to connect to.

=item port

  port => 80

Port to connect to, defaults to C<80> or C<443> with C<tls> option.

=item socket_options

  socket_options => {LocalAddr => '127.0.0.1'}

Additional options for L<IO::Socket::IP> when opening new connections.

=item socks_address

  socks_address => '127.0.0.1'

Address or host name of SOCKS5 proxy server to use for connection.

=item socks_pass

  socks_pass => 'secr3t'

Password to use for SOCKS5 authentication.

=item socks_port

  socks_port => 9050

Port of SOCKS5 proxy server to use for connection.

=item socks_user

  socks_user => 'sri'

Username to use for SOCKS5 authentication.

=item timeout

  timeout => 15

Maximum amount of time in seconds establishing connection may take before getting canceled, defaults to C<10>.

=item tls

  tls => 1

Enable TLS.

=item tls_ca

  tls_ca => '/etc/tls/ca.crt'

Path to TLS certificate authority file.

=item tls_cert

  tls_cert => '/etc/tls/client.crt'

Path to the TLS certificate file.

=item tls_key

  tls_key => '/etc/tls/client.key'

Path to the TLS key file.

=item tls_options

  tls_options => {SSL_alpn_protocols => ['foo', 'bar'], SSL_verify_mode => 0x00}

Additional options for L<IO::Socket::SSL>.

=back

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut

=pod

sub client {
  my ($self, $cb) = (_instance(shift), pop);

  my $id     = $self->_id;
  my $client = $self->{out}{$id}{client} = Mojo::IOLoop::Client->new(reactor => $self->reactor);

  weaken $self;
  $client->on(
    connect => sub {
      delete $self->{out}{$id}{client};
      my $stream = Mojo::IOLoop::Stream->new(pop);
      $self->_stream($stream => $id);
      $self->$cb(undef, $stream);
    }
  );
  $client->on(error => sub { $self->_remove($id); $self->$cb(pop, undef) });
  $client->connect(@_);

  return $id;
}

=cut
