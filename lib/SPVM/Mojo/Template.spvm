# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojo::Template {
  version_from Mojolicious;
  
  use Mojo::ByteStream;
  use Mojo::File;
  use Mojo::Util;
  use Native;
  use Native::MethodCall;
  
  # Fields
  has code : rw string;
  
  has unparsed : rw string;
  
  has compiled : rw string;
  
  has capture_end : rw string;
  
  has capture_start : rw string;
  
  has comment_mark : rw string;
  
  has escape_mark : rw string;
  
  has expression_mark : rw string;
  
  has trim_mark : rw string;
  
  has line_start : rw string;
  
  has replace_mark : rw string;
  
  has name : rw string;
  
  has tag_start : rw string;
  
  has tag_end : rw string;
  
  has auto_escape : rw byte;
  
  # Undocumented Fields
  has tree : rw string[][];

  # Class Methods
  static method new : Mojo::Template () {
    
    my $self = new Mojo::Template;
    
    $self->{code} = "";
    
    $self->{unparsed} = "";
    
    $self->{tag_start} = "<%";
    
    $self->{tag_end} = "%>";
    
    $self->{line_start} = "%";
    
    $self->{expression_mark} = "=";
    
    $self->{capture_end} = "end";
    
    $self->{capture_start} = "begin";
    
    $self->{comment_mark} = "#";
    
    $self->{escape_mark} = "=";
    
    $self->{trim_mark} = "=";
    
    $self->{replace_mark} = "%";
    
    $self->{name} = "template";
    
    $self->{tree} = new string[][0];
    
    return $self;
  }
  
  static method DEBUG : int () {
    return length(my $_ = Sys->env("SPVM_MOJO_TEMPLATE_DEBUG")) ? (int)$_ : 0;
  }
  
  
  method parse : void ($template : string) {
    
    # Clean start
    $self->set_unparsed($template);
    my $tree = (List of string[])List->new(new string[][0]);
    $self->set_tree($tree->get_array);
    $self->set_compiled(undef);
    
    my $tag_start = $self->tag_start; # <%
    my $tag_end = $self->tag_end; # %>
    my $line_start = $self->line_start; # %
    my $expression_mark = $self->expression_mark; # =
    
    my $escape_mark = $self->escape_mark; # =
    my $comment_mark = $self->comment_mark;
    my $replace_mark = $self->replace_mark; # %
    my $trim_mark    = $self->trim_mark;
    
    my $capture_start = $self->capture_start; # begin
    my $capture_end = $self->capture_end; # end
    
    my $line_code_re  = "^(\s*)\Q$line_start\E(?:(\Q$replace_mark\E)|(\Q$comment_mark\E)|(\Q$expression_mark\E))?(.*)$";
    
    my $code_re = "(\Q$tag_start\E(?:\Q$replace_mark\E|\Q$comment_mark\E)|\Q$tag_start$expression_mark\E(?:\Q$escape_mark\E)?(?:\s*\Q$capture_end\E\b)?|\Q$tag_start\E(?:\s*\Q$capture_end\E\b)?|(?:\b\Q$capture_start\E\s*)?(?:\Q$trim_mark\E)?\Q$tag_end\E)";
    
    my $capture_start_re  = "^(?:(\Q$capture_start\E)\s*)?(\Q$trim_mark\E)?\Q$tag_end\E$";
    my $capture_end_re = "^\Q$tag_start\E(?:\Q$expression_mark\E)?(?:\Q$escape_mark\E)?\s*\Q$capture_end\E(.*)$";
    
    # Split lines
    my $op = "text";
    my $trimming = (string)undef;
    my $capture = 0;
    my $lines = Fn->split("\n", $template);
    
    for my $line (@$lines) {
      
      # Turn Perl line into mixed line
      if ($op eq "text" && (my $m = Re->m($line, $line_code_re))) {
        
        # Escaped start
        if (length $m->cap2) { $line = $m->cap1 . $line_start . $m->cap5; }
        
        # Comment
        elsif (length $m->cap3) { $line = $tag_start . $m->cap3 . "$trim_mark$tag_end"; }
        
        # Expression or code
        else { $line = length $m->cap4 ? $m->cap1 . $tag_start . $m->cap4 . $m->cap5 . $tag_end : $tag_start . $m->cap5 . "$trim_mark$tag_end"; }
      }
      
      # Escaped line ending
      if (!Re->s((mutable string)$line, "\\\\\\\\$", "\\\\\n")) {
        if (Re->s((mutable string)$line, "\\\\$", "")) {
          $line .= "\n";
        }
      }
      
      # Mixed line
      my $tokens = Re->split($code_re, $line);
      for my $token (@$tokens) {
        # Capture end
        if (my $m = Re->m($token, $capture_end_re)) {
          $token = $tag_start . $m->cap1;
          $capture = 1;
        }
        
        # End
        if ($op ne "text" && (my $m = Re->m($token, $capture_start_re))) {
          
          # Capture start
          if (length $m->cap1) {
            $tree->splice($tree->length - 1, 0, ["cpst"]);
          }
          
          # Trim left side
          if (length($trimming = $m->cap2) && $tree->length > 1) {
            &_trim($tree);
          }
          
          # Hint at end
          $tree->push([$op = "text", ""]);
        }
        
        # Code
        elsif ($token eq $tag_start) { $op = "code"; }
        
        # Expression
        elsif ($token eq "$tag_start$expression_mark") { $op = "expr"; }
        
        # Expression that needs to be escaped
        elsif ($token eq "$tag_start$expression_mark$escape_mark") { $op = "escp"; }
        
        # Comment
        elsif ($token eq "$tag_start$comment_mark") { $op = "cmnt"; }
        
        # Text (comments are just ignored)
        elsif ($op ne "cmnt") {
          
          # Replace
          if ($token eq "$tag_start$replace_mark") {
            $token = $tag_start ;
          }
          
          # Trim right side (convert whitespace to line noise)
          if ($trimming && (my $r = Re->s((mutable string)$token, "^(\s+)", ""))) {
            $tree->push(["code", $r->match->cap1]);
            $trimming = 0;
          }
          
          # Token (with optional capture end)
          $tree->push($capture ? ["cpen"] : [$op, $token]);
          $capture = 0;
        }
      }
      
      $tree->push(["line", undef]);
    }
  }
  
  static method _trim : void ($tree : List of string[]) {
    
    # Skip captures
    my $len = $tree->length;
    my $i = $tree->[-2][0] eq "cpst" || $tree->[-2][0] eq "cpen" ? $len - 3 : $len - 2;
    
    # Only trim text
    unless ($tree->[$i][0] eq "text") {
      return;
    }
    
    # Convert whitespace text to line noise
    if (my $r = Re->s((mutable string)$tree->[$i][1], "(\s+)$", "")) {
      $tree->splice($i, 0, ["code", $r->match->cap1]);
    }
    
  }
  
  method process : string ($options : Hash|object[] = undef) {
    
    my $options = Fn->to_hash($options);
    
    # Use a local stack trace for compile exceptions
    my $compiled = $self->compiled;
    unless ($compiled) {
    
      $self->_compile;
      
      my $code = $self->code;
      
      unless ($compiled = Native->use_anon_class($code)) {
        # TODO 
        # return Mojo::Exception->new($@)->inspect($self->unparsed, $code)->trace->verbose(1)
        die $self->unparsed;
      }
      
      $self->set_compiled($compiled);
    }
    
    my $output = (string)Native::MethodCall->call_class_method($compiled, "code", [$options]);
    
    return $output;
  }
  
  private method _compile : void () {
    
    my $tree = (List of string[])List->new($self->tree);
    my $escape = $self->auto_escape;
    
    my $blocks = StringList->new;
    
    $blocks->push("class {");
    $blocks->push("  use Mojo::Util;");
    $blocks->push("  use Mojo::ByteStream;");
    $blocks->push("static method code : string (\$options : Hash) {");
    $blocks->push("my \$_O = \"\";");
    
    my $i = 0;
    my $capture = (string)undef;
    my $multi = 0;
    for (my $i = 0; $i < @$tree - 1; $i++) {
      
      my $token = $tree->[$i];
      my $op = $token->[0];
      my $value = $token->[1];
      
      my $next = $tree->[$i + 1];
      
      if ($op eq "line") {
        $blocks->push("");
        next;
      }
      
      my $value_length = length $value;
      
      $value = copy $value;
      
      Fn->chomp((mutable string)$value);
      
      my $newline = length $value != $value_length;
      
      $blocks->push("");
        
      # Text (quote and fix line ending)
      if ($op eq "text") {
        if (length $value) {
          $blocks->[-1] .= "\$_O .= <<'END_OF_STRING';\n" . $value . "\nEND_OF_STRING\n" ;
        }
      }
      
      # Code or multi-line expression
      elsif ($op eq "code" || $multi) {
        $blocks->[-1] .= $value;
      }
# Capture end
      elsif ($op eq "cpen") {
        $blocks->[-1] .= "return Mojo::ByteStream->new(\$_O) }";
        
        # No following code
        if ($next->[0] ne "cpst" && (Re->m($next->[1] // "", "^\s*$"))) {
          $blocks->[-1] .= ";" ;
        }
      }
      
      # Expression
      if ($op eq "expr" || $op eq "escp") {

        # Escaped
        if (!$multi && ($op eq "escp" && !$escape || $op eq "expr" && $escape)) {
          $blocks->[-1] .= "my \$_ = (object)$value;";
          $blocks->[-1] .= "\$_O .= \$_ isa Mojo::ByteStream ? \$_->(Mojo::ByteStream)->to_string : Mojo::Util->xml_escape((string)\$_);";
        }
        
        # Raw
        elsif (!$multi) {
          $blocks->[-1] .= "\$_O .= $value";
        }
        
        # Multi-line
        $multi = !$next || $next->[0] ne "text";
        
        # Append semicolon
        unless ($multi || $capture) {
          $blocks->[-1] .= ";";
        }
      }
      
      # Capture start
      if    ($op eq "cpst") { $capture = 1; }
      elsif ($capture) {
        $blocks->[-1] .= "method : void () { my \$_O = \"\"; ";
        $capture = 0;
      }
    }
    
    $blocks->push("return \$_O;");
    $blocks->push("} # End of method");
    $blocks->push("} # End of class");
    
    $self->set_code(Fn->join("\n", $blocks->to_array));
    
    $self->set_tree(new string[][0]);
  }
  
  method render : string ($template : string, $args : object[] = undef) {
    
    $self->parse($template);
    
    my $output = $self->process($args);
    
    return $output;
  }
  
  method render_file : string ($path : string, $args : object[] = undef) {
    
    unless ($self->{name}) {
      $self->set_name($path) ;
    }
    my $template = Mojo::File->path($path)->slurp;
    
    return $self->render($template, $args);
  }
  
}
