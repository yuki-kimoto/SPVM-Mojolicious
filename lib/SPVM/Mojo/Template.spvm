# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojo::Template {
  version_from Mojolicious;
  
  use Mojo::ByteStream;
  use Mojo::File;
  use Mojo::Util;
  use Native;
  use Native::MethodCall;
  
  # Fields
  has code : rw string;
  
  has unparsed : rw string;
  
  has compiled : rw string;
  
  has capture_end : rw string;
  
  has capture_start : rw string;
  
  has comment_mark : rw string;
  
  has escape_mark : rw string;
  
  has expression_mark : rw string;
  
  has trim_mark : rw string;
  
  has line_start : rw string;
  
  has replace_mark : rw string;
  
  has name : rw string;
  
  has tag_start : rw string;
  
  has tag_end : rw string;
  
  # Undocumented Fields
  has tree_list : rw List of string[];

  # Class Methods
  static method new : Mojo::Template () {
    
    my $self = new Mojo::Template;
    
    $self->{code} = "";
    
    $self->{unparsed} = "";
    
    $self->{capture_end} = "end";
    
    $self->{capture_start} = "begin";
    
    $self->{comment_mark} = "#";
    
    $self->{escape_mark} = "=";
    
    $self->{expression_mark} = "=";
    
    $self->{trim_mark} = "=";
    
    $self->{line_start} = "%";
    
    $self->{replace_mark} = "%";
    
    $self->{name} = "template";
    
    $self->{tag_start} = "<%";
    
    $self->{tag_end} = "%>";
    
    $self->{tree_list} = List->new;
    
    return $self;
  }
  
  static method DEBUG : int () {
    return length(my $_ = Sys->env("SPVM_MOJO_TEMPLATE_DEBUG")) ? (int)$_ : 0;
  }
  
  
  method parse : void ($template : string) {
    
    # Clean start
    $self->set_unparsed($template);
    my $tree_list = (List of string[])List->new(new string[][0]);
    $self->set_tree_list($tree_list);
    $self->set_compiled(0);
    
    my $tag     = $self->tag_start;
    my $replace = $self->replace_mark;
    my $expr    = $self->expression_mark;
    my $escp    = $self->escape_mark;
    my $cpen    = $self->capture_end;
    my $cmnt    = $self->comment_mark;
    my $cpst    = $self->capture_start;
    my $trim    = $self->trim_mark;
    my $end     = $self->tag_end;
    my $start   = $self->line_start;
    
    my $line_re  = "^(\s*)\Q$start\E(?:(\Q$replace\E)|(\Q$cmnt\E)|(\Q$expr\E))?(.*)$";
    my $token_re = "(\Q$tag\E(?:\Q$replace\E|\Q$cmnt\E)|\Q$tag$expr\E(?:\Q$escp\E)?(?:\s*\Q$cpen\E(?!\w))?|\Q$tag\E(?:\s*\Q$cpen\E(?!\w))?|(?:(?<!\w)\Q$cpst\E\s*)?(?:\Q$trim\E)?\Q$end\E)";
    my $cpen_re = "^\Q$tag\E(?:\Q$expr\E)?(?:\Q$escp\E)?\s*\Q$cpen\E(.*)$";
    my $end_re  = "^(?:(\Q$cpst\E)\s*)?(\Q$trim\E)?\Q$end\E$";
    
    # Split lines
    my $op = "text";
    my $trimming = (string)undef;
    my $capture = 0;
    for my $line (@{Fn->split("\n", $template)}) {
      
      # Turn Perl line into mixed line
      if ($op eq "text" && (my $m = Re->m($line, $line_re))) {
        
        # Escaped start
        if ($m->cap2) { $line = $m->cap1 . $start . $m->cap5; }
        
        # Comment
        elsif ($m->cap3) { $line = $tag . $m->cap3 . "$trim$end"; }
        
        # Expression or code
        else { $line = $m->cap4 ? $m->cap1 . $tag . $m->cap4 . $m->cap5 . $end : $tag . $m->cap5 . "$trim$end"; }
      }
      
      # Escaped line ending
      if (!Re->s(my $_ = [$line], "\\\\\\\\$", "\\\\\n")) {
        $line = $_->[0];
        if (Re->s(my $_ = [$line], "\\$", "")) {
          $line = $_->[0];
          $line .= "\n";
        }
      }
      
      # Mixed line
      for my $token (@{Re->split($token_re, $line)}) {
        
        # Capture end
        if (my $m = Re->m($token, $cpen_re)) {
          $token = $tag . $m->cap1;
          $capture = 1;
        }
        
        # End
        if ($op ne "text" && (my $m = Re->m($token, $end_re))) {
          
          # Capture start
          if ($m->cap1) {
            $tree_list->splice($tree_list->length - 1, 0, ["cpst"]);
          }
          
          # Trim left side
          if (($trimming = $m->cap2) && $tree_list->length > 1) {
            &_trim($tree_list);
          }
          
          # Hint at end
          $tree_list->push([$op = "text", ""]);
        }
        
        # Code
        elsif ($token eq $tag) { $op = "code"; }
        
        # Expression
        elsif ($token eq "$tag$expr") { $op = "expr"; }
        
        # Expression that needs to be escaped
        elsif ($token eq "$tag$expr$escp") { $op = "escp"; }
        
        # Comment
        elsif ($token eq "$tag$cmnt") { $op = "cmnt"; }
        
        # Text (comments are just ignored)
        elsif ($op ne "cmnt") {
          
          # Replace
          if ($token eq "$tag$replace") {
            $token = $tag ;
          }
          
          # Trim right side (convert whitespace to line noise)
          if ($trimming && (my $r = Re->s(my $_ = [$token], "^(\s+)", ""))) {
            $token = $_->[0];
            $tree_list->push(["code", $r->match->cap1]);
            $trimming = 0;
          }
          
          # Token (with optional capture end)
          $tree_list->push($capture ? ["cpen"] : [$op, $token]);
          $capture = 0;
        }
      }
      
      # Optimize successive text lines separated by a newline
      my $len = $tree_list->length;
      if ($tree_list->get($len - 4) && $tree_list->get($len - 4)->[0] ne "line"
        || (!$tree_list->get($len - 3) || $tree_list->get($len - 3)->[0] ne "text" || !Re->m($tree_list->get($len - 3)->[1], "\n$")
        || ($tree_list->get($len - 2)->[0] ne "line" || $tree_list->get($len - 1)->[0] ne "text")))
      {
        $tree_list->push(["line"]);
        next;
      }
      
      my $_ = $tree_list->get($len - 3);
      $_->[1] .= $tree_list->pop->[1];
    }
    
  }
  
  static method _trim : void ($tree_list : List of string[]) {
    
    # Skip captures
    my $len = $tree_list->length;
    my $i = $tree_list->get($len - 2)->[0] eq "cpst" || $tree_list->get($len - 2)->[0] eq "cpen" ? $len - 3 : $len - 2;
    
    # Only trim text
    unless ($tree_list->get($i)->[0] eq "text") {
      return;
    }
    
    # Convert whitespace text to line noise
    if (my $r = Re->s(my $_ = [$tree_list->get($i)->[1]], "(\s+)$", "")) {
      $tree_list->get($i)->[1] = $_->[0];
      $tree_list->splice($i, 0, ["code", $r->match->cap1]);
    }
    
  }
  
  method process : string ($args : object[]) {
    
    # Use a local stack trace for compile exceptions
    my $compiled = $self->compiled;
    unless ($compiled) {
      $self->_compile;
      my $code = $self->code;
      
      unless ($compiled = Native->use_anon_class($code)) {
        # TODO 
        # return Mojo::Exception->new($@)->inspect($self->unparsed, $code)->trace->verbose(1)
        die $self->unparsed;
      }
      
      $self->set_compiled($compiled);
    }
    
    my $output = (string)Native::MethodCall->call_class_method($compiled, "", $args);
    
    return $output;
  }
  
  private method _compile : void () {

=pod

    my $tree   = $self->tree;
    my $escape = $self->auto_escape;

    my @blocks = ('');
    my ($i, $capture, $multi);
    while (++$i <= @$tree && (my $next = $tree->[$i])) {
      my ($op, $value) = @{$tree->[$i - 1]};
      push @blocks, '' and next if $op eq 'line';
      my $newline = chomp($value //= '');

      # Text (quote and fix line ending)
      if ($op eq 'text') {
        $value = join "\n", map { quotemeta $_ } split(/\n/, $value, -1);
        $value      .= '\n'                          if $newline;
        $blocks[-1] .= "\$_O .= \"" . $value . "\";" if length $value;
      }

      # Code or multi-line expression
      elsif ($op eq 'code' || $multi) { $blocks[-1] .= $value }

      # Capture end
      elsif ($op eq 'cpen') {
        $blocks[-1] .= 'return Mojo::ByteStream->new($_O) }';

        # No following code
        $blocks[-1] .= ';' if $next->[0] ne 'cpst' && ($next->[1] // '') =~ /^\s*$/;
      }

      # Expression
      if ($op eq 'expr' || $op eq 'escp') {

        # Escaped
        if (!$multi && ($op eq 'escp' && !$escape || $op eq 'expr' && $escape)) {
          $blocks[-1] .= "\$_O .= _escape scalar + $value";
        }

        # Raw
        elsif (!$multi) { $blocks[-1] .= "\$_O .= scalar + $value" }

        # Multi-line
        $multi = !$next || $next->[0] ne 'text';

        # Append semicolon
        $blocks[-1] .= ';' unless $multi || $capture;
      }

      # Capture start
      if    ($op eq 'cpst') { $capture = 1 }
      elsif ($capture) {
        $blocks[-1] .= "sub { my \$_O = ''; ";
        $capture = 0;
      }
    }

    return $self->code(join "\n", @blocks)->tree([]);

=cut

  }
  
}

__END__

sub render { shift->parse(shift)->process(@_) }

sub render_file {
  my ($self, $path) = (shift, shift);

  $self->name($path) unless defined $self->{name};
  my $template = path($path)->slurp;
  my $encoding = $self->encoding;
  croak qq{Template "$path" has invalid encoding} if $encoding && !defined($template = decode $encoding, $template);

  return $self->render($template, @_);
}

