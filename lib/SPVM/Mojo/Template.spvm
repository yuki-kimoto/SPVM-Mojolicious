# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojo::Template {
  version_from Mojolicious;
  
  use Mojo::ByteStream;
  use Mojo::File;
  use Mojo::Util;
  use Native;
  use Native::MethodCall;
  
  # Fields
  has code : rw string;
  
  has unparsed : rw string;
  
  has compiled : rw string;
  
  has capture_end : rw string;
  
  has capture_start : rw string;
  
  has comment_mark : rw string;
  
  has escape_mark : rw string;
  
  has expression_mark : rw string;
  
  has trim_mark : rw string;
  
  has line_start : rw string;
  
  has replace_mark : rw string;
  
  has name : rw string;
  
  has tag_start : rw string;
  
  has tag_end : rw string;
  
  has auto_escape : rw byte;
  
  # Undocumented Fields
  has tree : rw string[][];

  # Class Methods
  static method new : Mojo::Template () {
    
    my $self = new Mojo::Template;
    
    $self->{code} = "";
    
    $self->{unparsed} = "";
    
    $self->{tag_start} = "<%";
    
    $self->{tag_end} = "%>";
    
    $self->{line_start} = "%";
    
    $self->{expression_mark} = "=";
    
    $self->{capture_end} = "end";
    
    $self->{capture_start} = "begin";
    
    $self->{comment_mark} = "#";
    
    $self->{escape_mark} = "=";
    
    $self->{trim_mark} = "=";
    
    $self->{replace_mark} = "%";
    
    $self->{name} = "template";
    
    $self->{tree} = new string[][0];
    
    return $self;
  }
  
  static method DEBUG : int () {
    return length(my $_ = Sys->env("SPVM_MOJO_TEMPLATE_DEBUG")) ? (int)$_ : 0;
  }
  
  
  method parse : void ($template : string) {
    
    my $tree_tmp = $self->tokenize($template);
    $self->check($tree_tmp);
    
    # Clean start
    $self->set_unparsed($template);
    my $tree = (List of string[])List->new(new string[][0]);
    $self->set_tree($tree->get_array);
    $self->set_compiled(undef);
    
    my $tag_start = $self->tag_start; # <%
    my $tag_end = $self->tag_end; # %>
    my $line_start = $self->line_start; # %
    my $expression_mark = $self->expression_mark; # =
    
    my $escape_mark = $self->escape_mark; # =
    my $comment_mark = $self->comment_mark;
    my $replace_mark = $self->replace_mark; # %
    my $trim_mark    = $self->trim_mark; # =
    
    my $capture_start = $self->capture_start; # begin
    my $capture_end = $self->capture_end; # end
    
    my $line_code_re  = "^(\s*)\Q$line_start\E(?:(\Q$replace_mark\E)|(\Q$comment_mark\E)|(\Q$expression_mark\E))?(.*)$";
    
    my $code_re = "(\Q$tag_start\E(?:\Q$replace_mark\E|\Q$comment_mark\E)|\Q$tag_start$expression_mark\E(?:\Q$escape_mark\E)?(?:\s*\Q$capture_end\E\b)?|\Q$tag_start\E(?:\s*\Q$capture_end\E\b)?|(?:\b\Q$capture_start\E\s*)?(?:\Q$trim_mark\E)?\Q$tag_end\E)";
    
    my $tag_end_re  = "^(?:(\Q$capture_start\E)\s*)?(\Q$trim_mark\E)?\Q$tag_end\E$";
    my $capture_end_re = "^\Q$tag_start\E(?:\Q$expression_mark\E)?(?:\Q$escape_mark\E)?\s*\Q$capture_end\E(.*)$";
    
    # Split lines
    my $op = "text";
    my $capture = 0;
    my $lines = Fn->split("\n", $template);
    
    for my $line (@$lines) {
      
      # Turn Perl line into mixed line
      if ($op eq "text" && (my $m = Re->m($line, $line_code_re))) {
        
        # Escaped start
        if (length $m->cap2) { $line = $m->cap1 . $line_start . $m->cap5; }
        
        # Comment
        elsif (length $m->cap3) { $line = $tag_start . $m->cap3 . "$tag_end"; }
        
        # Expression or code
        else { $line = length $m->cap4 ? $m->cap1 . $tag_start . $m->cap4 . $m->cap5 . $tag_end : $tag_start . $m->cap5 . "$tag_end"; }
      }
      
      # Escaped line ending
      my $escape_line_ending = 0;
      if (!Re->s((mutable string)$line, "\\\\\\\\$", "\\")) {
        if (Re->s((mutable string)$line, "\\\\$", "")) {
          $escape_line_ending = 1;
        }
      }
      
      # Mixed line
      my $has_text = 0;
      my $tokens = Re->split($code_re, $line);
      for my $token (@$tokens) {
        # Capture end
        if (my $m = Re->m($token, $capture_end_re)) {
          $token = $tag_start . $m->cap1;
          $capture = 1;
        }
        
        # End
        if ($op ne "text" && (my $m = Re->m($token, $tag_end_re))) {
          
          # Capture start
          if (length $m->cap1) {
            $tree->splice($tree->length - 1, 0, ["capture_start"]);
          }
          
          if (length $m->cap2) {
            die "Do not support trim mark =%>";
          }
          
          # Hint at end
          $tree->push([$op = "text", ""]);
        }
        
        # Code
        elsif ($token eq $tag_start) { $op = "code"; }
        
        # Expression
        elsif ($token eq "$tag_start$expression_mark") { $op = "expression"; }
        
        # Expression that needs to be escaped
        elsif ($token eq "$tag_start$expression_mark$escape_mark") { $op = "excaped_expression"; }
        
        # Comment
        elsif ($token eq "$tag_start$comment_mark") { $op = "cmnt"; }
        
        # Text (comments are just ignored)
        elsif ($op ne "cmnt") {
          # Replace
          if ($token eq "$tag_start$replace_mark") {
            $token = $tag_start ;
          }
          
          # Token (with optional capture end)
          $tree->push($capture ? ["capture_end"] : [$op, $token]);
          $capture = 0;
          if ($op eq "text" && length $token) {
            $has_text++;
          }
        }
      }
      
      if ($op eq "text" && $has_text && !$escape_line_ending) {
        $tree->push(["line_end", undef]);
      }
    }
    
    # Hint at end
    $tree->push(["text", ""]);
  }
  
  method parse_v2 : void ($template : string) {
    
    $self->set_unparsed($template);
    $self->set_compiled(undef);
    
    my $tree = $self->tokenize($template);
    
    $self->check($tree);
    
    $self->set_tree($tree);
  }
  
  private method tokenize : string[][] ($template : string) {
    
    my $tree = (List of string[])List->new(new string[][0]);
    
    my $line_start = $self->line_start;           # %
    my $tag_start = $self->tag_start;             # <%
    my $replace_mark = $self->replace_mark;       # %
    my $comment_mark = $self->comment_mark;       # #
    my $expression_mark = $self->expression_mark; # =
    my $escape_mark = $self->escape_mark;         # =
    
    my $trim_mark = $self->trim_mark;             # =
    my $tag_end = $self->tag_end;                 # %>
    
    my $capture_start = $self->capture_start;     # begin
    my $capture_end = $self->capture_end;         # end
    
    my $line_code_re  = "^(\s*)\Q$line_start\E(?:(\Q$replace_mark\E)|(\Q$comment_mark\E)|(\Q$expression_mark\E))?(.*)$";
    
    my $code_re = "(\Q$tag_start\E(?:\Q$replace_mark\E|\Q$comment_mark\E)|\Q$tag_start$expression_mark\E(?:\Q$escape_mark\E)?(?:\s*\Q$capture_end\E\b)?|\Q$tag_start\E(?:\s*\Q$capture_end\E\b)?|(?:\b\Q$capture_start\E\s*)?(?:\Q$trim_mark\E)?\Q$tag_end\E)";
    
    my $tag_end_re  = "^(?:(\Q$capture_start\E)\s*)?(\Q$trim_mark\E)?\Q$tag_end\E$";
    my $capture_end_re = "^\Q$tag_start\E(?:\Q$expression_mark\E)?(?:\Q$escape_mark\E)?\s*\Q$capture_end\E(.*)$";
    
    # Split lines
    my $lines = Fn->split("\n", $template);
    
    my $op = "text";
    my $is_capture_end = 0;
    for (my $line_index = 0; $line_index < @$lines; $line_index++) {
      
      my $line = $lines->[$line_index];
      
      $tree->push(["line_start", $line_index + 1]);
      
      if (is_read_only $line) {
        $line = copy $line;
      }
      
      # Turn Perl line into mixed line
      if ($op eq "text" && (my $m = Re->m($line, $line_code_re))) {
        
        # Escaped start
        if (length $m->cap2) { $line = $m->cap1 . $line_start . $m->cap5; }
        
        # Comment
        elsif (length $m->cap3) { $line = $tag_start . $m->cap3 . "$trim_mark$tag_end"; }
        
        # Expression or code
        else { $line = length $m->cap4 ? $m->cap1 . $tag_start . $m->cap4 . $m->cap5 . $tag_end : $tag_start . $m->cap5 . "$trim_mark$tag_end"; }
      }
      
      # Escaped line ending
      my $escape_line_ending = 0;
      if (!Re->s((mutable string)$line, "\\\\\\\\$", "\\")) {
        if (Re->s((mutable string)$line, "\\\\$", "")) {
          $escape_line_ending = 1;
        }
      }
      
      # Mixed line
      my $tokens = Re->split($code_re, $line);
      for my $token (@$tokens) {
        # Capture end
        if (my $m = Re->m($token, $capture_end_re)) {
          $token = $tag_start . $m->cap1;
          $is_capture_end = 1;
        }
        
        # Tag End
        if ($op ne "text" && (my $m = Re->m($token, $tag_end_re))) {
          
          # Capture start
          if (length $m->cap1) {
            $tree->push(["capture_start"]);
          }
          
          my $trim = (string)undef;
          if (length $m->cap2) {
            $trim = "trim";
          }
          $tree->push(["tag_end", $trim]);
          
          $op = "text";
        }
        
        # Tag start - Comment
        elsif ($token eq "$tag_start$comment_mark") {
          $op = "cmnt";
          $tree->push(["tag_start", $op]);
        }
        
        # Tag start - Expression that needs to be escaped
        elsif ($token eq "$tag_start$expression_mark$escape_mark") {
          $op = "excaped_expression";
          $tree->push(["tag_start", $op]);
        }
        
        # Tag start - Expression
        elsif ($token eq "$tag_start$expression_mark") {
          $op = "expression";
          $tree->push(["tag_start", $op]);
        }
        
        # Tag start
        elsif ($token eq $tag_start) {
          $op = "code";
          $tree->push(["tag_start", $op]);
        }
        
        # Text
        else {
          # Token (with optional capture end)
          if ($is_capture_end) {
            $tree->push(["capture_end"]);
          }
          else {
            # Replace
            if ($token eq "$tag_start$replace_mark") {
              $token = $tag_start ;
            }
            
            $tree->push([$op, $token]);
          }
          $is_capture_end = 0;
        }
      }
      
      unless ($escape_line_ending) {
        $tree->push([$op, "\n"]);
        $tree->push(["line_end", undef]);
      }
    }
    
    return $tree->to_array;
  }
  
  private method check : void ($tree : string[][]) {
    
    # Process trim mark
    for (my $tree_index = 0; $tree_index < @$tree; $tree_index++) {
      
      my $token = $tree->[$tree_index];
      
      my $op = $token->[0];
      
      if ($op eq "tag_end") {
        my $trim = $token->[1];
        
        if ($trim) {
          # Remove previous spaces
          my $tag_start_index = -1;
          for (my $tree_index_prev = $tree_index - 1; $tree_index_prev >= 0; $tree_index_prev--) {
            my $token_prev = $tree->[$tree_index_prev];
            my $op_prev = $token_prev->[0];
            
            if ($op_prev eq "tag_start") {
              $tag_start_index = $tree_index_prev;
            }
          }
          if ($tag_start_index >= 0) {
            for (my $tree_index_prev = $tag_start_index - 1; $tree_index_prev >= 0; $tree_index_prev--) {
              my $token_prev = $tree->[$tree_index_prev];
              my $op_prev = $token_prev->[0];
              
              if ($op_prev eq "text") {
                if (my $m = Re->m($token_prev->[1], "(.*?)\s+$")) {
                  $token_prev->[1] = $m->cap1;
                }
                if (length $token_prev->[1]) {
                  last;
                }
              }
              else {
                last;
              }
            }
          }
          
          # Remove later spaces
          for (my $tree_index_later = $tree_index + 1; $tree_index_later < @$tree; $tree_index_later++) {
            my $token_later = $tree->[$tree_index_later];
            
            my $op_later = $token_later->[0];
            unless ($op_later eq "text" | $op_later eq "line_end") {
              last;
            }
            
            if ($op_later eq "text") {
              if (my $m = Re->m($token_later->[1], "^\s+(.*)")) {
                $token_later->[1] = $m->cap1;
              }
              if (length $token_later->[1]) {
                last;
              }
            }
            else {
              last;
            }
          }
        }
      }
    }
    
    # Merge text and expression
    for my $target_op (@{["text", "excaped_expression", "expression"]}) {
      my $tree_index = 0;
      while (1) {
        
        if ($tree_index == @$tree) {
          last;
        }
        
        my $base_tree_index = -1;
        
        my $token = $tree->[$tree_index];
        my $op = $token->[0];
        
        if ($op eq $target_op) {
          $base_tree_index = $tree_index;
          my $next = 0;
          while (1) {
            $tree_index++;
            if ($tree_index + 2 < @$tree && $tree->[$tree_index][0] eq "line_end" && $tree->[$tree_index + 1][0] eq "line_start" && $tree->[$tree_index + 2][0] eq $target_op) {
              $tree->[$base_tree_index][1] .= $tree->[$tree_index + 2][1];
              $tree->[$tree_index][0] = "none";
              $tree->[$tree_index][1] = "";
              $tree->[$tree_index + 1][0] = "none";
              $tree->[$tree_index + 1][1] = "";
              $tree->[$tree_index + 2][0] = "none";
              $tree->[$tree_index + 2][1] = "";
              $tree_index += 2;
            }
            elsif ($tree->[$tree_index][0] eq $target_op) {
              $tree->[$base_tree_index][1] .= $tree->[$tree_index][1];
              $tree->[$tree_index][0] = "none";
              $tree->[$tree_index][1] = "";
            }
            else {
              $next = 1;
              last;
            }
          }
          
          if ($next) {
            next;
          }
        }
        
        $tree_index++;
      }
    }
    
  }
  
  method process : string ($options : Hash|object[] = undef, $c : Mojolicious::Controller = undef) {
    
    my $options = Fn->to_hash($options);
    
    # Use a local stack trace for compile exceptions
    my $compiled = $self->compiled;
    unless ($compiled) {
    
      $self->_compile;
      
      my $code = $self->code;
      
      unless ($compiled = Native->use_anon_class($code)) {
        # TODO 
        # return Mojo::Exception->new($@)->inspect($self->unparsed, $code)->trace->verbose(1)
        die $self->unparsed;
      }
      
      $self->set_compiled($compiled);
    }
    
    my $output = (string)Native::MethodCall->call_class_method($compiled, "code", [(object)$options, $c]);
    
    return $output;
  }
  
  private method _compile_v2 : void () {
    
    my $tree = (List of string[])List->new($self->tree);
    my $escape = $self->auto_escape;
    
    my $blocks = StringList->new;
    
    $blocks->push("class {");
    $blocks->push("  use Mojo::Util;");
    $blocks->push("  use Mojo::ByteStream;");
    $blocks->push("static method code : string (\$options : Hash = undef, \$c : Mojolicious::Controller = undef) {");
    $blocks->push("my \$_O = \"\";");
    
    my $i = 0;
    my $capture = (string)undef;
    for (my $i = 0; $i < @$tree; $i++) {
      
      my $token = $tree->[$i];
      my $op = $token->[0];
      my $value = $token->[1];
      
      # Text
      if ($op eq "text") {
        my $lines = Fn->split("\n", $value, -1);
        
        $blocks->[-1] .= "\$_O .= <<'END_OF_STRING';\n";
        
        for my $line (@$lines) {
          $blocks->[-1] .= "$line\n" ;
        }
        
        $blocks->[-1] .= "END_OF_STRING\n";
        
        $blocks->[-1] .= "Fn->chomp((mutable string)\$_O);" ;
      }
      
      # Code
      elsif ($op eq "code") {
        $blocks->[-1] .= $value;
      }
      # Expression or escapaced expr
      elsif ($op eq "expression" || $op eq "excaped_expression") {
        
        # Escaped
        if ($op eq "excaped_expression" && !$escape || $op eq "expression" && $escape) {
          $blocks->[-1] .= "my \$_ = (object)$value;";
          $blocks->[-1] .= "\$_O .= \$_ isa Mojo::ByteStream ? \$_->(Mojo::ByteStream)->to_string : Mojo::Util->xml_escape((string)\$_);";
        }
        
        # Raw
        else {
          $blocks->[-1] .= "\$_O .= $value";
        }
        
        $blocks->[-1] .= ";\n";
      }
    }
    
    $blocks->push("return \$_O;");
    $blocks->push("} # End of method");
    $blocks->push("} # End of class");
    
    $self->set_code(Fn->join("\n", $blocks->to_array));
    
    $self->set_tree(new string[][0]);
  }
  
  private method _compile : void () {
    
    my $tree = (List of string[])List->new($self->tree);
    my $escape = $self->auto_escape;
    
    my $blocks = StringList->new;
    
    $blocks->push("class {");
    $blocks->push("  use Mojo::Util;");
    $blocks->push("  use Mojo::ByteStream;");
    $blocks->push("static method code : string (\$options : Hash = undef, \$c : Mojolicious::Controller = undef) {");
    $blocks->push("my \$_O = \"\";");
    
    my $i = 0;
    my $capture = (string)undef;
    my $multi = 0;
    for (my $i = 0; $i < @$tree - 1; $i++) {
      
      my $token = $tree->[$i];
      my $op = $token->[0];
      my $value = $token->[1];
      
      my $next = $tree->[$i + 1];
      
      my $value_length = length $value;
      
      $value = copy $value;
      
      $blocks->push("");
      
      # Text (quote and fix line ending)
      if ($op eq "line_end") {
        $blocks->[-1] .= "\$_O .= \"\\n\";" ;
      }
      elsif ($op eq "text") {
        if (length $value) {
          $blocks->[-1] .= "\$_O .= <<'END_OF_STRING';\n" . $value . "\nEND_OF_STRING\n" ;
          $blocks->[-1] .= "Fn->chomp((mutable string)\$_O);" ;
        }
      }
      
      # Code or multi-line expression
      elsif ($op eq "code" || $multi) {
        $blocks->[-1] .= $value;
      }
# Capture end
      elsif ($op eq "capture_end") {
        $blocks->[-1] .= "return Mojo::ByteStream->new(\$_O) }";
        
        # No following code
        if ($next->[0] ne "capture_start" && (Re->m($next->[1] // "", "^\s*$"))) {
          $blocks->[-1] .= ";" ;
        }
      }
      
      # Expression
      if ($op eq "expression" || $op eq "excaped_expression") {
        
        # Escaped
        if (!$multi && ($op eq "excaped_expression" && !$escape || $op eq "expression" && $escape)) {
          $blocks->[-1] .= "my \$_ = (object)$value;";
          $blocks->[-1] .= "\$_O .= \$_ isa Mojo::ByteStream ? \$_->(Mojo::ByteStream)->to_string : Mojo::Util->xml_escape((string)\$_);";
        }
        
        # Raw
        elsif (!$multi) {
          $blocks->[-1] .= "\$_O .= $value";
        }
        
        # Multi-line
        $multi = !$next || $next->[0] ne "text";
        
        # Append semicolon
        unless ($multi || $capture) {
          $blocks->[-1] .= ";";
        }
      }
      
      # Capture start
      if    ($op eq "capture_start") { $capture = 1; }
      elsif ($capture) {
        $blocks->[-1] .= "method : void () { my \$_O = \"\"; ";
        $capture = 0;
      }
    }
    
    $blocks->push("return \$_O;");
    $blocks->push("} # End of method");
    $blocks->push("} # End of class");
    
    $self->set_code(Fn->join("\n", $blocks->to_array));
    
    $self->set_tree(new string[][0]);
  }
  
  method render : string ($template : string, $args : object[] = undef) {
    
    $self->parse($template);
    
    my $output = $self->process($args);
    
    return $output;
  }
  
  method render_file : string ($path : string, $args : object[] = undef) {
    
    unless ($self->{name}) {
      $self->set_name($path) ;
    }
    my $template = Mojo::File->path($path)->slurp;
    
    return $self->render($template, $args);
  }
  
}
