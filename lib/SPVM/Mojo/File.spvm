# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojo::File {
  version_from Mojolicious;
  
  use File::Temp;
  use File::Temp::Dir;
  use File::Spec;
  use Cwd;
  use File::Basename;
  use File::Copy;
  use Mojo::Collection;
  use File::Find;
  use File::Path;
  
  # Undocumented Fields
  has path : object of string|File::Temp|File::Temp::Dir;
  
  # Class Methods
  static method new : Mojo::File ($path : object of string|string[]|File::Temp|File::Temp::Dir) {
    
    my $self = new Mojo::File;
    
    if (!$path) {
      $self->{path} = File::Spec->canonpath(Cwd->getcwd);
    }
    elsif ($path isa string || $path isa File::Temp || $path isa File::Temp::Dir) {
      $self->{path} = $path;
    }
    elsif ($path isa string[]) {
      my $pathes = (string[])$path;
      for my $_ (@$pathes) {
        unless ($_) {
          die "Invalid path";
        }
      }
      $self->{path} = File::Spec->catfile($pathes);
    }
    else {
      die "The path \$path is an invalid type.";
    }
    
    return $self;
  }
  
  static method path : Mojo::File ($path : object of string|string[]|File::Temp|File::Temp::Dir) {
    return &new($path);
  }
  
  # Instance Methods
  method basename : string () {
    
    my $basename = File::Basename->basename($self->to_string);
    
    return $basename;
  }
  
  method child : Mojo::File ($base_name : object of string|string[]) {
    
    my $child = Mojo::File->new($base_name);
    
    return $child;
  }
  
  method chmod : void ($mode : int) {
    
    Sys->chmod($mode, $self->to_string);
  }
  
  method copy_to : Mojo::File ($to : string) {
    
    File::Copy->copy($self->to_string, $to);
    
    my $new_args = (object of string|string[])undef;
    if (Sys->d($to)) {
      $new_args = [$to, $self->basename];
    }
    else {
      $new_args = $to;
    }
    my $new_file = Mojo::File->new($new_args);
    
    return $new_file;
  }
  
  method dirname : Mojo::File () {
    
    my $dirname_file = Mojo::File->new(File::Basename->dirname($self->to_string));
    
    return $dirname_file;
  }
  
  method extname : string () {
    my $basename = $self->basename;
    
    if (my $_ = Re->m($basename, ".+\.([^.]+)$")) {
      return $_->cap1;
    }
    else {
      return "";
    }
  }
  
  method is_abs : int () {
    return File::Spec->file_name_is_absolute($self->to_string);
  }
  
  method list : Mojo::Collection ($options : object[] = undef) {
    
    my $options_h = Hash->new($options);
    
    my $path_file_name = $self->to_string;
    
    unless (Sys->d($path_file_name)) {
      return Mojo::Collection->new;
    }
    
    my $dh = IO->opendir($path_file_name);
    
    my $mojo_files_list = List->new(new Mojo::File[0]);
    
    my $files_list = StringList->new;
    while (my $file = $dh->read) {
      unless ($file ne "." && $file ne "..") {
        next;
      }
      
      unless ($options_h->get_int("hidden")) {
        if (Re->m($file, "^\.")) {
          next;
        }
      }
      
      $file = File::Spec->catfile([$path_file_name, $file]);
      
      unless ($options_h->get("dir")) {
        if (Sys->d($file)) {
          next;
        }
      }
      
      $files_list->push($file);
    }
    
    my $files = $files_list->to_array;
    
    Sort->sort_string_asc($files);
    
    my $mojo_files = new Mojo::File[@$files];
    
    for (my $i = 0; $i < @$files; $i++) {
      my $file = $files->[$i];
      $mojo_files->[$i] = Mojo::File->new($file);
    }
    
    return Mojo::Collection->new($mojo_files);
  }
  
  method list_tree : Mojo::Collection ($options : object[] = undef) {
    
    my $options_h = Hash->new($options);
    
    my $path_file_name = $self->to_string;
    
    my $all = Hash->new;
    
    if (Sys->d($path_file_name)) {
      my $wanted = [$options_h : Hash, $path_file_name : string, $all : Hash] method : void ($info : File::Find::Info) {
        
        my $name = $info->name;
        
        unless ($options_h->get_int("hidden")) {
          if (Re->m($name, "^\.")) {
            return;
          }
        }
        
        if ($options_h->get_int("max_depth")) {
          my $rel = $name;
          
          Re->s(my $_ = [$rel], "^\Q$path_file_name\E/?", "");
          $rel = $_->[0];
          
          if (@{File::Spec->splitdir($rel)} >= $options_h->get_int("max_depth")) {
            $info->set_prune(1);
          }
        }
        
        if ($options_h->get_int("dir") || !Sys->d($name)) {
          $all->set($name => 1);
        }
      };
    }
    
    $all->delete($path_file_name);
    
    my $files = $all->keys;
    
    Sort->sort_string_asc($files);
    
    my $collection = Mojo::Collection->new(new Mojo::File[0]);
    for my $file (@$files) {
      
      $file = File::Spec->canonpath($file);
      
      my $mojo_file = Mojo::File->new($file);
      
      $collection->push($mojo_file);
    }
    
    return $collection;
  }
  
  method lstat : Sys::IO::Stat () {
    
    my $lstat = Sys->lstat($self->to_string);
    
    return $lstat;
  }
  
  method make_path : void ($options : object[] = undef) {
    
    File::Path->make_path($self->to_string, $options);
  }
  
  method move_to : Mojo::File ($to : string) {
    
    my $path_file_name = $self->to_string;
    
    File::Copy->move($path_file_name, $to);
    
    my $new_args = (object of string|string[])undef;
    if (Sys->d($to)) {
      $new_args = [$to, File::Basename->basename($path_file_name)];
    }
    else {
      $new_args = $to;
    }
    
    my $mojo_file = Mojo::File->new($new_args);
    
    return $mojo_file;
  }
  
  method open : IO::File ($mode : string) {
    
    my $handle = IO::File->new;
    
    $handle->open($self->to_string, $mode);
    
    return $handle;
  }
  
  method realpath : Mojo::File () {
    return Mojo::File->new(Cwd->realpath($self->to_string));
  }
  
  method remove : void () {
    
    my $path_file_name = $self->to_string;
    if (Sys->e($path_file_name)) {
      Sys->unlink($path_file_name);
    }
  }

  method to_array : string[] () {
    
    return File::Spec->splitdir($self->to_string);
  }
  
  method to_abs : Mojo::File () {
    
    my $abs = Mojo::File->new(File::Spec->rel2abs($self->to_string));
    
    return $abs;
  }
  
  method to_string : string () {
    
    my $string = (string)undef;
    
    my $path = $self->{path};
    if ($path) {
      if ($path isa string) {
        $string = (string)$path;
      }
      elsif ($path isa File::Temp) {
        $string = $path->(File::Temp)->filename;
      }
      elsif ($path isa File::Temp::Dir) {
        $string = $path->(File::Temp::Dir)->dirname;
      }
    }
    
    return $string;
  }
  
}
