# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojo::Connection::Stream extends Mojo::Connection {
  version_from Mojolicious;
  
  has high_water_mark : rw int
    get {
      unless (exists $self->{high_water_mark}) {
        $self->{high_water_mark} = 1048576;
      }
      return $self->{high_water_mark};
    }
  ;
  
  # Class Methods
  static method new : Mojo::Connection::Stream () {
    
    my $self = new Mojo::Connection::Stream;
    
    $self->{timeout} = 15;
    
    return $self;
  }
  
  # Instance Methods
  method write : void ($chunk : string, $cb : Mojo::Callback = undef) {
    
    die "TODO";
    
=pod

    # IO::Socket::SSL will corrupt data with the wrong internal representation
    utf8::downgrade $chunk;
    $self->{buffer} .= $chunk;
    if    ($cb)                     { $self->once(drain => $cb) }
    elsif (!length $self->{buffer}) { return $self }
    $self->reactor->watch($self->{handle}, !$self->{paused}, 1) if $self->{handle};
    
    return $self;

=cut

  }

}

__END__

sub bytes_read { shift->{read} || 0 }

sub bytes_waiting { length(shift->{buffer} // '') }

sub bytes_written { shift->{written} || 0 }

sub can_write { $_[0]{handle} && $_[0]->bytes_waiting < $_[0]->high_water_mark }

sub close_gracefully { $_[0]->is_writing ? $_[0]{graceful}++ : $_[0]->close }

sub is_readable {
  my $self = shift;
  $self->_again;
  return $self->{handle} && Mojo::Util::_readable(0, fileno $self->{handle});
}

sub is_writing {
  my $self = shift;
  return undef unless $self->{handle};
  return !!length($self->{buffer}) || $self->has_subscribers('drain');
}

sub start {
  my $self = shift;

  # Resume
  return unless $self->{handle};
  my $reactor = $self->reactor;
  return $reactor->watch($self->{handle}, 1, $self->is_writing) if delete $self->{paused};

  weaken $self;
  my $cb = sub { pop() ? $self->_write : $self->_read };
  $reactor->io($self->timeout($self->{timeout})->{handle} => $cb);
}

sub steal_handle {
  my $self = shift;
  $self->reactor->remove($self->{handle});
  return delete $self->{handle};
}

sub stop { $_[0]->reactor->watch($_[0]{handle}, 0, $_[0]->is_writing) if $_[0]{handle} && !$_[0]{paused}++ }

sub timeout {
  my ($self, $timeout) = @_;

  return $self->{timeout} unless defined $timeout;
  $self->{timeout} = $timeout;

  my $reactor = $self->reactor;
  if ($self->{timer}) {
    if   (!$self->{timeout}) { $reactor->remove(delete $self->{timer}) }
    else                     { $reactor->again($self->{timer}, $self->{timeout}) }
  }
  elsif ($self->{timeout}) {
    weaken $self;
    $self->{timer}
      = $reactor->timer($timeout => sub { $self and delete($self->{timer}) and $self->emit('timeout')->close });
  }

  return $self;
}

sub write {
  my ($self, $chunk, $cb) = @_;

  # IO::Socket::SSL will corrupt data with the wrong internal representation
  utf8::downgrade $chunk;
  $self->{buffer} .= $chunk;
  if    ($cb)                     { $self->once(drain => $cb) }
  elsif (!length $self->{buffer}) { return $self }
  $self->reactor->watch($self->{handle}, !$self->{paused}, 1) if $self->{handle};

  return $self;
}

sub _again { $_[0]->reactor->again($_[0]{timer}) if $_[0]{timer} }

sub _read {
  my $self = shift;

  if (defined(my $read = $self->{handle}->sysread(my $buffer, 131072, 0))) {
    $self->{read} += $read;
    return $read == 0 ? $self->close : $self->emit(read => $buffer)->_again;
  }

  # Retry
  return undef if $! == EAGAIN || $! == EINTR || $! == EWOULDBLOCK;

  # Closed (maybe real error)
  $! == ECONNRESET ? $self->close : $self->emit(error => $!)->close;
}

sub _write {
  my $self = shift;

  # Handle errors only when reading (to avoid timing problems)
  my $handle = $self->{handle};
  if (length $self->{buffer}) {
    return undef unless defined(my $written = $handle->syswrite($self->{buffer}));
    $self->{written} += $written;
    $self->emit(write => substr($self->{buffer}, 0, $written, ''))->_again;
  }

  # Clear the buffer to free the underlying SV* memory
  undef $self->{buffer}, $self->emit('drain') unless length $self->{buffer};
  return undef                                        if $self->is_writing;
  return $self->close                                 if $self->{graceful};
  $self->reactor->watch($handle, !$self->{paused}, 0) if $self->{handle};
}

1;

