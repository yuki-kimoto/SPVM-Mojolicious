# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojo::Connection::Stream extends Mojo::Connection {
  version_from Mojolicious;
  
  use StringBuffer;
  
  has high_water_mark : rw int
    get {
      unless (exists $self->{high_water_mark}) {
        $self->{high_water_mark} = 1048576;
      }
      return $self->{high_water_mark};
    }
  ;
  
  # Undocumented Fields
  has read : int;
  
  has buffer : StringBuffer;
  
  has written : int;
  
  has graceful : byte;
  
  # Class Methods
  static method new : Mojo::Connection::Stream () {
    
    my $self = new Mojo::Connection::Stream;
    
    $self->{timeout} = 15;
    
    $self->{buffer} = StringBuffer->new;
    
    return $self;
  }
  
  # Instance Methods
  method bytes_read : int () {
    return $self->{read};
  }
  
  method bytes_waiting : int () {
    return $self->{buffer}->length;
  }
  
  method bytes_written : int () {
    
    return $self->{written};
  }
  
  method can_write : int () {
    return $self->{handle} && $self->bytes_waiting < $self->high_water_mark;
  }
  
  method close : void () {
    
    # TODO: if gorutine scheduler is not yet run, reutrn.
    $self->set_timeout(0);
    my $handle = $self->{handle};
    unless ($handle) {
      return;
    }
    
    $self->emit("close");
  }
  
  method close_gracefully : void () {
    
    if ($self->is_writing) {
      $self->{graceful}++;
    }
    else {
      $self->close;
    }
  }
  
  method is_writing : int () {
    
    unless ($self->{handle}) {
      return 0;
    }
    return !!$self->{buffer}->length || $self->has_subscribers("drain");
  }
  
  method write : void ($chunk : string, $cb : Mojo::Callback = undef) {
    
    $self->{buffer}->push($chunk);
    if ($cb) {
      $self->once(drain => $cb);
    }
    elsif (!$self->{buffer}->length) {
      return;
    }
    
    $self->_write;
    
    return;
  }
  
  private method _read : void () {
    
    my $handle = $self->{handle};
    my $buffer = (mutable string)new_string_len 131072;
    my $read = $handle->read($buffer);
    
    $self->{read} += $read;
    
    if ($read == 0) {
      $self->close;
    }
    else {
      Fn->shorten($buffer, $read);
      $self->emit(read => $buffer);
    }
  }
  
  private method _write : void () {
    
    # Handle errors only when reading (to avoid timing problems)
    my $handle = $self->{handle};
    my $buffer = $self->{buffer};
    
    while (1) {
      if ($buffer->length) {
        my $written = $handle->write($buffer->get_string_unsafe, $buffer->length);
        
        unless ($written) {
          last;
        }
        
        $self->{written} += $written;
        
        my $chunk = $buffer->substr(0, $written);
        
        $buffer->replace(0, $written, "");
        
        $self->emit(write => $chunk);
      }
    }
    
    $self->emit("drain");
    
    if ($self->{graceful}) {
      $self->close;
    }
  }

}
