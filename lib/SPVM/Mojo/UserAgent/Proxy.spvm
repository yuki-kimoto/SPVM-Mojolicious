# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojo::UserAgent::Proxy {
  version_from Mojolicious;
  
  use Mojo::URL;
  use Mojo::Transaction::HTTP;
  
  use Sys;
  use Re;
  
  # Fields
  has http : rw string;
  
  has https : rw string;
  
  has not : rw string[];
  
  # Class Methods
  static method new : Mojo::UserAgent::Proxy ($options : object[] = undef) {
    
    my $options_h = Hash->new($options);
    
    my $self = new Mojo::UserAgent::Proxy;
    
    $self->{http} = $options_h->get_string("http");
    
    $self->{https} = $options_h->get_string("https");
    
    $self->{not} = (string[])$options_h->get("not");
    
    return $self;
  }
  
  # Instance Methods
  method detect : void () {
    
    if (length (my $_ = Sys->env("HTTP_PROXY"))) {
      $self->{http} = $_;
    }
    elsif (length (my $_ = Sys->env("http_proxy"))) {
      $self->{http} = $_;
    }
    
    if (length (my $_ = Sys->env("HTTPS_PROXY"))) {
      $self->{https} = $_;
    }
    elsif (length (my $_ = Sys->env("https_proxy"))) {
      $self->{https} = $_;
    }
    
    my $no_proxy = (string)undef;
    if (length (my $_ = Sys->env("NO_PROXY"))) {
      $no_proxy = $_;
    }
    elsif (length (my $_ = Sys->env("no_proxy"))) {
      $no_proxy = $_;
    }
    if ($no_proxy) {
      $self->{not} = Fn->split(",", $no_proxy);
    }
    
  }
  
  method is_needed : int ($domain : string)  {
    
    unless ($domain) {
      die "The domain \$domain must be defined";
    }
    
    my $not_needed = 0;
    for my $not_domain (@{$self->not // new string[0]}) {
      if (Re->m($domain, "\Q$not_domain\E$")) {
        $not_needed = 1;
        last;
      }
    }
    
    return !$not_needed;
  }
  
  method prepare : void ($tx : Mojo::Transaction::HTTP) {
    
    if (length Sys->env("SPVM_MOJO_PROXY")) {
      $self->detect;
    }
    
    my $req = $tx->req;
    my $url = $req->url;
    unless ($self->is_needed($url->host)) {
      return;
    }
    # HTTP proxy
    my $proto = $url->protocol;
    my $http  = $self->http;
    if ($http && $proto eq "http") {
      $req->set_proxy(Mojo::URL->new($http));
    }
    
    # HTTPS proxy
    my $https = $self->https;
    if ($https && $proto eq "https") {
      $req->set_proxy(Mojo::URL->new($https));
    }
    
  }

}

__END__

package Mojo::UserAgent::Proxy;
use Mojo::Base -base;

use Mojo::URL;

has [qw(http https not)];

sub detect {
  my $self = shift;
  $self->http($ENV{HTTP_PROXY}   || $ENV{http_proxy});
  $self->https($ENV{HTTPS_PROXY} || $ENV{https_proxy});
  return $self->not([split /,/, $ENV{NO_PROXY} || $ENV{no_proxy} || '']);
}

sub is_needed {
  !grep { $_[1] =~ /\Q$_\E$/ } @{$_[0]->not // []};
}

sub prepare {
  my ($self, $tx) = @_;

  $self->detect if $ENV{MOJO_PROXY};
  my $req = $tx->req;
  my $url = $req->url;
  return unless $self->is_needed($url->host);

  # HTTP proxy
  my $proto = $url->protocol;
  my $http  = $self->http;
  $req->proxy(Mojo::URL->new($http)) if $http && $proto eq 'http';

  # HTTPS proxy
  my $https = $self->https;
  $req->proxy(Mojo::URL->new($https)) if $https && $proto eq 'https';
}

1;

=encoding utf8

=head1 NAME

Mojo::UserAgent::Proxy - User agent proxy manager

=head1 SYNOPSIS

  use Mojo::UserAgent::Proxy;

  my $proxy = Mojo::UserAgent::Proxy->new;
  $proxy->detect;
  say $proxy->http;

=head1 DESCRIPTION

L<Mojo::UserAgent::Proxy> manages proxy servers for L<Mojo::UserAgent>.

=head1 ATTRIBUTES

L<Mojo::UserAgent::Proxy> implements the following attributes.

=head2 http

  my $http = $proxy->http;
  $proxy   = $proxy->http('socks://sri:secret@127.0.0.1:8080');

Proxy server to use for HTTP and WebSocket requests.

=head2 https

  my $https = $proxy->https;
  $proxy    = $proxy->https('http://sri:secret@127.0.0.1:8080');

Proxy server to use for HTTPS and WebSocket requests.

=head2 not

  my $not = $proxy->not;
  $proxy  = $proxy->not(['localhost', 'intranet.mojolicious.org']);

Domains that don't require a proxy server to be used.

=head1 METHODS

L<Mojo::UserAgent::Proxy> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 detect

  $proxy = $proxy->detect;

Check environment variables C<HTTP_PROXY>, C<http_proxy>, C<HTTPS_PROXY>, C<https_proxy>, C<NO_PROXY> and C<no_proxy>
for proxy information. Automatic proxy detection can be enabled with the C<MOJO_PROXY> environment variable.

=head2 is_needed

  my $bool = $proxy->is_needed('intranet.example.com');

Check if request for domain would use a proxy server.

=head2 prepare

  $proxy->prepare(Mojo::Transaction::HTTP->new);

Prepare proxy server information for transaction.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut