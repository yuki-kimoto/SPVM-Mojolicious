# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojo::Server::Daemon extends Mojo::Server {
  version_from Mojolicious;
  
  use Mojo::Transaction::WebSocket;
  use Mojo::URL;
  use Mojo::Util;
  use Mojo::WebSocket;
  use IO::Socket;
  use IO::Socket::IP;
  
  # Fields
  has acceptors : rw IO::Socket[];
  
  has backlog : rw int;
  
  has max_clients : rw int;
  
  has inactivity_timeout : rw int
    get {
      unless (exists $self->{inactivity_timeout}) {
        $self->{inactivity_timeout} = length(my $_ = Sys->env("SPVM_MOJO_INACTIVITY_TIMEOUT")) ? (int)$_ : 30;
      }
      return $self->{inactivity_timeout};
    }
  ;
  
  has keep_alive_timeout : rw int
    get {
      unless (exists $self->{keep_alive_timeout}) {
        $self->{keep_alive_timeout} = length(my $_ = Sys->env("SPVM_MOJO_KEEP_ALIVE_TIMEOUT")) ? (int)$_ : 5;
      }
      return $self->{keep_alive_timeout};
    }
  ;
  
  has max_requests : rw int
    get {
      unless (exists $self->{max_requests}) {
        $self->{max_requests} = 100;
      }
      return $self->{max_requests};
    }
  ;
  
  has listen : rw string[]
    get {
      unless (exists $self->{listen}) {
        $self->{listen} = length(my $_ = Sys->env("SPVM_MOJO_KEEP_ALIVE_TIMEOUT")) ? Fn->split(",", $_) : ["http://*:3000"];
      }
      return $self->{listen};
    }
  ;
  
  has reverse_proxy : rw byte;
  
  has trusted_proxies : rw string[];
  
  # Undocumented Fields
  has servers : IO::Socket[];
  
  # Class Methods
  static method new : Mojo::Server::Daemon () {
    
    my $self = new Mojo::Server::Daemon;
    
    return $self;
  }
  
  static method DEBUG : int () {
    return length(my $_ = Sys->env("SPVM_MOJO_SERVER_DEBUG")) ? (int)$_ : 0;
  }
  
  # Instance Methods
  method ports : int[] () {
    
    my $acceptors = $self->acceptors;
    
    my $ports_list = IntList->new;
    for (my $i = 0; $i < @$acceptors; $i++) {
      my $handle = $acceptors->[$i];
      $ports_list->push($handle->(IO::Socket::IP)->sockport);
    }
    
    return $ports_list->to_array;
  }
  
  method run : void () {
    
    # TODO
    # local $SIG{INT} = local $SIG{TERM} = sub { $self->stop };
    
    $self->start;
  }
  
  method start : void () {
    
    my $max = $self->max_clients;
    
    # Resume accepting connections
    if (my $servers = $self->{servers}) {
      $self->set_acceptors($self->{servers});
    }
    
    # Start listening
    elsif (!@{$self->acceptors}) {
      $self->app->server($self);
      for my $_ (@{$self->listen}) {
        $self->_listen($_);
      }
    }
  }
  
  method _listen : void ($listen : string) {
    
  }
  
}

__END__

sub stop {
  my $self = shift;

  # Suspend accepting connections but keep listen sockets open
  my $loop = $self->ioloop;
  while (my $id = shift @{$self->acceptors}) {
    my $server = $self->{servers}{$id} = $loop->acceptor($id);
    $loop->remove($id);
    $server->stop;
  }

  return $self;
}

sub _build_tx {
  my ($self, $id, $c) = @_;

  my $tx = $self->build_tx->connection($id);
  $tx->res->headers->server('Mojolicious (Perl)');
  my $handle = $self->ioloop->stream($id)->timeout($self->inactivity_timeout)->handle;
  unless ($handle->isa('IO::Socket::UNIX')) {
    $tx->local_address($handle->sockhost)->local_port($handle->sockport);
    $tx->remote_address($handle->peerhost)->remote_port($handle->peerport);
  }
  $tx->req->url->base->scheme('https') if $c->{tls};

  weaken $self;
  $tx->on(
    request => sub {
      my $tx = shift;

      my $req = $tx->req;
      if (my $error = $req->error) { $self->_trace($id, $error->{message}) }

      # WebSocket
      if ($req->is_handshake) {
        my $ws = $self->{connections}{$id}{next} = Mojo::Transaction::WebSocket->new(handshake => $tx);
        $self->emit(request => server_handshake $ws);
      }

      # HTTP
      else { $self->emit(request => $tx) }

      # Last keep-alive request or corrupted connection
      my $c = $self->{connections}{$id};
      $tx->res->headers->connection('close') if ($c->{requests} || 1) >= $self->max_requests || $req->error;

      $tx->on(resume => sub { $self->_write($id) });
      $self->_write($id);
    }
  );

  # Kept alive if we have more than one request on the connection
  return ++$c->{requests} > 1 ? $tx->kept_alive(1) : $tx;
}

sub _close {
  my ($self, $id) = @_;
  if (my $tx = $self->{connections}{$id}{tx}) { $tx->closed }
  delete $self->{connections}{$id};
}

sub _trace { $_[0]->app->log->trace($_[2]) if $_[0]{connections}{$_[1]}{tx} }

sub _finish {
  my ($self, $id) = @_;

  # Always remove connection for WebSockets
  my $c = $self->{connections}{$id};
  return unless my $tx = $c->{tx};
  return $self->_remove($id) if $tx->is_websocket;

  # Finish transaction
  delete($c->{tx})->closed;

  # Upgrade connection to WebSocket
  if (my $ws = delete $c->{next}) {

    # Successful upgrade
    if ($ws->handshake->res->code == 101) {
      $c->{tx} = $ws->established(1);
      weaken $self;
      $ws->on(resume => sub { $self->_write($id) });
      $self->_write($id);
    }

    # Failed upgrade
    else { $ws->closed }
  }

  # Close connection if necessary
  return $self->_remove($id) if $tx->error || !$tx->keep_alive;

  # Build new transaction for leftovers
  if (length(my $leftovers = $tx->req->content->leftovers)) {
    $tx = $c->{tx} = $self->_build_tx($id, $c);
    $tx->server_read($leftovers);
  }

  # Keep-alive connection
  $self->ioloop->stream($id)->timeout($self->keep_alive_timeout) unless $c->{tx};
}

sub _listen {
  my ($self, $listen) = @_;

  my $url   = Mojo::URL->new($listen);
  my $proto = $url->protocol;
  croak qq{Invalid listen location "$listen"} unless $proto eq 'http' || $proto eq 'https' || $proto eq 'http+unix';

  my $query   = $url->query;
  my $options = {backlog => $self->backlog};
  $options->{$_} = $query->param($_) for qw(fd single_accept reuse);
  if ($proto eq 'http+unix') { $options->{path} = $url->host }
  else {
    if ((my $host = $url->host) ne '*') { $options->{address} = $host }
    if (my $port = $url->port) { $options->{port} = $port }
  }

  $options->{tls_ca} = $query->param('ca');
  /^(.*)_(cert|key)$/ and $options->{"tls_$2"}{$1} = $query->param($_) for @{$query->names};
  if (my $cert = $query->param('cert')) { $options->{tls_cert}{''} = $cert }
  if (my $key  = $query->param('key'))  { $options->{tls_key}{''}  = $key }
  my ($ciphers, $verify, $version) = ($query->param('ciphers'), $query->param('verify'), $query->param('version'));
  $options->{tls_options}{SSL_cipher_list} = $ciphers    if defined $ciphers;
  $options->{tls_options}{SSL_verify_mode} = hex $verify if defined $verify;
  $options->{tls_options}{SSL_version}     = $version    if defined $version;
  my $tls = $options->{tls} = $proto eq 'https';

  weaken $self;
  push @{$self->acceptors}, $self->ioloop->server(
    $options => sub {
      my ($loop, $stream, $id) = @_;

      $self->{connections}{$id} = {tls => $tls};
      warn "-- Accept $id (@{[_peer($stream->handle)]})\n" if DEBUG;
      $stream->timeout($self->inactivity_timeout);

      $stream->on(close   => sub { $self && $self->_close($id) });
      $stream->on(error   => sub { $self && $self->app->log->error(pop) && $self->_close($id) });
      $stream->on(read    => sub { $self->_read($id => pop) });
      $stream->on(timeout => sub { $self->_trace($id, 'Inactivity timeout (see FAQ for more)') });
    }
  );

  return if $self->silent;
  $self->app->log->info(qq{Listening at "$url"});
  $query->pairs([]);
  $url->host('127.0.0.1')        if $url->host eq '*';
  $url->port($self->ports->[-1]) if !$options->{path} && !$url->port;
  say 'Web application available at ', $options->{path} // $url;
}

sub _peer { $_[0]->isa('IO::Socket::UNIX') ? $_[0]->peerpath : $_[0]->peerhost }

sub _read {
  my ($self, $id, $chunk) = @_;

  # Make sure we have a transaction
  my $c  = $self->{connections}{$id};
  my $tx = $c->{tx} ||= $self->_build_tx($id, $c);
  warn term_escape "-- Server <<< Client (@{[_url($tx)]})\n$chunk\n" if DEBUG;
  $tx->server_read($chunk);
}

sub _remove {
  my ($self, $id) = @_;
  $self->ioloop->remove($id);
  $self->_close($id);
}

sub _url { shift->req->url->to_abs }

sub _write {
  my ($self, $id) = @_;

  # Protect from resume event recursion
  my $c = $self->{connections}{$id};
  return if !(my $tx = $c->{tx}) || $c->{writing};
  local $c->{writing} = 1;
  my $chunk = $tx->server_write;
  warn term_escape "-- Server >>> Client (@{[_url($tx)]})\n$chunk\n" if DEBUG;
  my $next = $tx->is_finished ? '_finish' : length $chunk ? '_write' : undef;
  return $self->ioloop->stream($id)->write($chunk) unless $next;
  weaken $self;
  $self->ioloop->stream($id)->write($chunk => sub { $self->$next($id) });
}




package Mojo::IOLoop::Server;
use Mojo::Base 'Mojo::EventEmitter';

use Carp qw(croak);
use IO::Socket::IP;
use IO::Socket::UNIX;
use Mojo::File qw(path);
use Mojo::IOLoop;
use Mojo::IOLoop::TLS;
use Scalar::Util qw(weaken);
use Socket       qw(IPPROTO_TCP TCP_NODELAY);

has reactor => sub { Mojo::IOLoop->singleton->reactor }, weak => 1;

sub DESTROY {
  my $self = shift;
  $ENV{MOJO_REUSE} =~ s/(?:^|\,)\Q$self->{reuse}\E// if $self->{reuse};
  $self->stop                                        if $self->{handle} && $self->reactor;
}

sub generate_port { IO::Socket::IP->new(Listen => 5, LocalAddr => '127.0.0.1')->sockport }

sub handle { shift->{handle} }

sub is_accepting { !!shift->{active} }

sub listen {
  my ($self, $args) = (shift, ref $_[0] ? $_[0] : {@_});

  # Look for reusable file descriptor
  my $path    = $args->{path};
  my $address = $args->{address} || '0.0.0.0';
  my $port    = $args->{port};
  $ENV{MOJO_REUSE} ||= '';
  my $fd = ($path && $ENV{MOJO_REUSE} =~ /(?:^|\,)unix:\Q$path\E:(\d+)/)
    || ($port && $ENV{MOJO_REUSE} =~ /(?:^|\,)\Q$address:$port\E:(\d+)/) ? $1 : undef;

  # Allow file descriptor inheritance
  local $^F = 1023;

  # Reuse file descriptor
  my $handle;
  my $class = $path ? 'IO::Socket::UNIX' : 'IO::Socket::IP';
  if (defined($fd //= $args->{fd})) {
    $handle = $class->new_from_fd($fd, 'r') or croak "Can't open file descriptor $fd: $!";
  }

  else {
    my %options = (Listen => $args->{backlog} // SOMAXCONN, Type => SOCK_STREAM);

    # UNIX domain socket
    my $reuse;
    if ($path) {
      path($path)->remove if -S $path;
      $options{Local} = $path;
      $handle         = $class->new(%options) or croak "Can't create listen socket: $!";
      $reuse          = $self->{reuse} = join ':', 'unix', $path, fileno $handle;
    }

    # IP socket
    else {
      $options{LocalAddr} = $address;
      $options{LocalAddr} =~ y/[]//d;
      $options{LocalPort} = $port if $port;
      $options{ReuseAddr} = 1;
      $options{ReusePort} = $args->{reuse};
      $handle             = $class->new(%options) or croak "Can't create listen socket: $@";
      $fd                 = fileno $handle;
      $reuse              = $self->{reuse} = join ':', $address, $handle->sockport, $fd;
    }

    $ENV{MOJO_REUSE} .= length $ENV{MOJO_REUSE} ? ",$reuse" : "$reuse";
  }
  $handle->blocking(0);
  @$self{qw(args handle)} = ($args, $handle);

  croak 'IO::Socket::SSL 2.009+ required for TLS support' if !Mojo::IOLoop::TLS->can_tls && $args->{tls};
}

sub port { shift->{handle}->sockport }

sub start {
  my $self = shift;
  weaken $self;
  ++$self->{active} and $self->reactor->io($self->{handle} => sub { $self->_accept })->watch($self->{handle}, 1, 0);
}

sub stop { delete($_[0]{active}) and $_[0]->reactor->remove($_[0]{handle}) }

sub _accept {
  my $self = shift;

  # Greedy accept
  my $args     = $self->{args};
  my $accepted = 0;
  while ($self->{active} && !($args->{single_accept} && $accepted++)) {
    return unless my $handle = $self->{handle}->accept;
    $handle->blocking(0);

    # Disable Nagle's algorithm
    setsockopt $handle, IPPROTO_TCP, TCP_NODELAY, 1;

    $self->emit(accept => $handle) and next unless $args->{tls};

    # Start TLS handshake
    my $tls = Mojo::IOLoop::TLS->new($handle)->reactor($self->reactor);
    $tls->on(upgrade => sub { $self->emit(accept => pop) });
    $tls->on(error   => sub { });
    $tls->negotiate(%$args, server => 1);
  }
}

