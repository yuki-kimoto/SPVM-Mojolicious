# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojo::Server::Daemon extends Mojo::Server {
  version_from Mojolicious;
  
  use Mojo::Transaction::WebSocket;
  use Mojo::URL;
  use Mojo::Util;
  use Mojo::WebSocket;
  use IO::Socket;
  use IO::Socket::IP;
  use Mojo::Connection::Server;
  use Mojo::Connection::Stream;
  
  # Fields
  has acceptors : rw Mojo::Connection::Server[];
  
  has backlog : rw int;
  
  has max_clients : rw int;
  
  has inactivity_timeout : rw int
    get {
      unless (exists $self->{inactivity_timeout}) {
        $self->{inactivity_timeout} = length(my $_ = Sys->env("SPVM_MOJO_INACTIVITY_TIMEOUT")) ? (int)$_ : 30;
      }
      return $self->{inactivity_timeout};
    }
  ;
  
  has keep_alive_timeout : rw int
    get {
      unless (exists $self->{keep_alive_timeout}) {
        $self->{keep_alive_timeout} = length(my $_ = Sys->env("SPVM_MOJO_KEEP_ALIVE_TIMEOUT")) ? (int)$_ : 5;
      }
      return $self->{keep_alive_timeout};
    }
  ;
  
  has max_requests : rw int
    get {
      unless (exists $self->{max_requests}) {
        $self->{max_requests} = 100;
      }
      return $self->{max_requests};
    }
  ;
  
  has listen : rw string[]
    get {
      unless (exists $self->{listen}) {
        $self->{listen} = length(my $_ = Sys->env("SPVM_MOJO_KEEP_ALIVE_TIMEOUT")) ? Fn->split(",", $_) : ["http://*:3000"];
      }
      return $self->{listen};
    }
  ;
  
  has reverse_proxy : rw byte;
  
  has trusted_proxies : rw string[];
  
  # Undocumented Fields
  has servers : Mojo::Connection::Server[];
  
  # Class Methods
  static method new : Mojo::Server::Daemon () {
    
    my $self = new Mojo::Server::Daemon;
    
    return $self;
  }
  
  static method DEBUG : int () {
    return length(my $_ = Sys->env("SPVM_MOJO_SERVER_DEBUG")) ? (int)$_ : 0;
  }
  
  # Instance Methods
  method ports : int[] () {
    
    my $acceptors = $self->acceptors;
    
    my $ports_list = IntList->new;
    for (my $i = 0; $i < @$acceptors; $i++) {
      my $handle = $acceptors->[$i];
      $ports_list->push($handle->port);
    }
    
    return $ports_list->to_array;
  }
  
  method run : void () {
    
    # TODO
    # local $SIG{INT} = local $SIG{TERM} = sub { $self->stop };
    
    $self->start;
  }
  
  method start : void () {
    
    my $max = $self->max_clients;
    
    # Resume accepting connections
    if (my $servers = $self->{servers}) {
      $self->set_acceptors($self->{servers});
    }
    
    # Start listening
    elsif (!@{$self->acceptors}) {
      $self->app->server($self);
      for my $_ (@{$self->listen}) {
        $self->_listen($_);
      }
    }
  }
  
  method _listen : void ($listen : string) {
    
  }
  
  method stop : void () {
    
    for my $server (@{$self->acceptors}) {
      $server->stop;
    }
    
  }
  
  method _build_tx : Mojo::Transaction::HTTP ($conn_accepted : Mojo::Connection::Stream) {
    
    my $tx = $self->build_tx;
    
    $tx->set_connection($conn_accepted);
    
    $tx->res->headers->set_server("Mojolicious (SPVM)");
    
    my $handle = $conn_accepted->handle;
    
    # TODO: set this to goroutine
    $conn_accepted->set_timeout($self->inactivity_timeout);
    
    unless ($handle isa IO::Socket::UNIX) {
      $tx->set_local_address($handle->(IO::Socket::IP)->sockhost);
      $tx->set_local_port($handle->(IO::Socket::IP)->sockport);
      $tx->set_remote_address($handle->(IO::Socket::IP)->peerhost);
      $tx->set_remote_port($handle->(IO::Socket::IP)->peerport);
    }
    
    if ($conn_accepted->tls) {
      $tx->req->url->base->set_scheme("https");
    }
    
    my $request_cb = [$this : Mojo::Server::Daemon = $self, $conn_accepted : Mojo::Connection::Stream] method : void ($tx : Mojo::Transaction::HTTP) {
      
      my $req = $tx->req;
      
      # WebSocket
      if ($req->is_handshake) {
        
        my $ws = Mojo::Transaction::WebSocket->new;
        $ws->set_handshake($tx);
        
        $conn_accepted->set_next($ws);
        
        $this->emit(request => Mojo::WebSocket->server_handshake($ws));
      }
      
      # HTTP
      else { $this->emit(request => $tx); }
      
      # Last keep-alive request or corrupted connection
      if (($conn_accepted->requests || 1) >= $this->max_requests) {
        $tx->res->headers->set_connection("close");
      }
      
      my $resume_cb = [$this : Mojo::Server::Daemon, $conn_accepted : Mojo::Connection::Stream] method : void () {
        $this->_write($conn_accepted);
      };
      
      $tx->on(resume => $resume_cb);
      $this->_write($conn_accepted);
    };
    weaken $request_cb->{this};
    
    $tx->on(request => $request_cb);
    
    # Kept alive if we have more than one request on the connection
    my $requests = $conn_accepted->requests;
    ++$requests;
    
    if ($requests > 1) {
      $tx->set_kept_alive(1);
    }
    
    $conn_accepted->set_requests($requests);
    
    return $tx;
  }
  
  method _write : void ($c : Mojo::Connection::Stream) {
    
    # Protect from resume event recursion
    my $tx = $c->tx;
    if (!$tx || $c->writing) {
      return;
    }
    
    my $writing_save = $c->writing;
    Fn->defer([$c : Mojo::Connection::Stream, $writing_save : int] method : void () {
      $c->set_writing($writing_save);
    });
    
    $c->set_writing(1);
    
    my $chunk = $tx->server_write;
    if (&DEBUG) {
      # warn term_escape "-- Server >>> Client (@{[_url($tx)]})\n$chunk\n" ;
    }
    my $next = $tx->is_finished ? "_finish" : length $chunk ? "_write" : undef;
    
    unless ($next) {
      $c->write($chunk);
      return;
    }
    
    my $write_cb = [$this : Mojo::Server::Daemon = $self, $next : string, $c : Mojo::Connection::Stream] method : void () {
      if ($next eq "_finish") {
        $this->_finish($c);
      }
      elsif ($next eq "_write") {
        $this->_write($c);
      }
      else {
        die "[Unexpected Error]\$next is invalid.";
      }
    };
    weaken $write_cb->{this};
    
    $c->write($chunk => $write_cb);
    
  }
  
  method _finish : void ($c : Mojo::Connection::Stream) {
    
    # Always remove connection for WebSockets
    my $tx = $c->tx;
    unless ($tx) {
      return;
    }
    
    $tx->closed;
    
    my $ws = (Mojo::Transaction::WebSocket)$c->next;
    $c->set_next(undef);
    
    # Upgrade connection to WebSocket
    if ($ws) {
      # Successful upgrade
      if ($ws->handshake->res->code == 101) {
        $ws->set_established(1);
        $c->set_tx($ws);
        $ws->on(resume => [$this : Mojo::Server::Daemon = $self, $c : Mojo::Connection::Stream] method : void () {
          $this->_write($c);
        });
        $self->_write($c);
      }
      
      # Failed upgrade
      else { $ws->closed; }
    }
    
    # Close connection if necessary
    if ($tx isa Mojo::Transaction::HTTP && !$tx->(Mojo::Transaction::HTTP)->keep_alive) {
      $tx->closed;
    }
    
    # Build new transaction for leftovers
    if (length(my $leftovers = $tx->req->content->leftovers)) {
    
      $tx = $self->_build_tx($c);
      
      $c->set_tx($tx);
      
      $tx->server_read($leftovers);
    }
    
    # Keep-alive connection
    unless ($c->tx) {
      $c->set_timeout($self->keep_alive_timeout);
    }
  }

}

__END__

sub _trace { $_[0]->app->log->trace($_[2]) if $_[0]{connections}{$_[1]}{tx} }

sub _listen {
  my ($self, $listen) = @_;

  my $url   = Mojo::URL->new($listen);
  my $proto = $url->protocol;
  croak qq{Invalid listen location "$listen"} unless $proto eq 'http' || $proto eq 'https' || $proto eq 'http+unix';

  my $query   = $url->query;
  my $options = {backlog => $self->backlog};
  $options->{$_} = $query->param($_) for qw(fd single_accept reuse);
  if ($proto eq 'http+unix') { $options->{path} = $url->host }
  else {
    if ((my $host = $url->host) ne '*') { $options->{address} = $host }
    if (my $port = $url->port) { $options->{port} = $port }
  }

  $options->{tls_ca} = $query->param('ca');
  /^(.*)_(cert|key)$/ and $options->{"tls_$2"}{$1} = $query->param($_) for @{$query->names};
  if (my $cert = $query->param('cert')) { $options->{tls_cert}{''} = $cert }
  if (my $key  = $query->param('key'))  { $options->{tls_key}{''}  = $key }
  my ($ciphers, $verify, $version) = ($query->param('ciphers'), $query->param('verify'), $query->param('version'));
  $options->{tls_options}{SSL_cipher_list} = $ciphers    if defined $ciphers;
  $options->{tls_options}{SSL_verify_mode} = hex $verify if defined $verify;
  $options->{tls_options}{SSL_version}     = $version    if defined $version;
  my $tls = $options->{tls} = $proto eq 'https';

  weaken $self;
  push @{$self->acceptors}, $self->ioloop->server(
    $options => sub {
      my ($loop, $stream, $id) = @_;

      $self->{connections}{$id} = {tls => $tls};
      warn "-- Accept $id (@{[_peer($stream->handle)]})\n" if DEBUG;
      $stream->timeout($self->inactivity_timeout);

      $stream->on(close   => sub { $self && $self->_close($id) });
      $stream->on(error   => sub { $self && $self->app->log->error(pop) && $self->_close($id) });
      $stream->on(read    => sub { $self->_read($id => pop) });
      $stream->on(timeout => sub { $self->_trace($id, 'Inactivity timeout (see FAQ for more)') });
    }
  );

  return if $self->silent;
  $self->app->log->info(qq{Listening at "$url"});
  $query->pairs([]);
  $url->host('127.0.0.1')        if $url->host eq '*';
  $url->port($self->ports->[-1]) if !$options->{path} && !$url->port;
  say 'Web application available at ', $options->{path} // $url;
}

sub _peer { $_[0]->isa('IO::Socket::UNIX') ? $_[0]->peerpath : $_[0]->peerhost }

sub _read {
  my ($self, $id, $chunk) = @_;

  # Make sure we have a transaction
  my $c  = $self->{connections}{$id};
  my $tx = $c->{tx} ||= $self->_build_tx($id, $c);
  warn term_escape "-- Server <<< Client (@{[_url($tx)]})\n$chunk\n" if DEBUG;
  $tx->server_read($chunk);
}

sub _url { shift->req->url->to_abs }




