# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojo::Server::CGI extends Mojo::Server {
  version_from Mojolicious;
  
  # Fields
  has nph : rw byte;
  
  # Class Methods
  static method new : Mojo::Server::CGI () {
    
    my $self = new Mojo::Server::CGI;
    
    return $self;
  }
  
  # Instance Methods
  method run : void () {
    
    die "TODO";

=pod

    $self->app->server($self);
    
    my $tx  = $self->build_tx;
    my $req = $tx->req->parse(\%ENV);
    $tx->local_port($ENV{SERVER_PORT})->remote_address($ENV{REMOTE_ADDR});
    
    # Request body (may block if we try to read too much)
    binmode STDIN;
    my $len = $req->headers->content_length;
    until ($req->is_finished) {
      my $chunk = ($len && $len < 131072) ? $len : 131072;
      last unless my $read = STDIN->read(my $buffer, $chunk, 0);
      $req->parse($buffer);
      last if ($len -= $read) <= 0;
    }
    
    $self->emit(request => $tx);
    
    # Response start-line
    STDOUT->autoflush(1);
    binmode STDOUT;
    my $res = $tx->res->fix_headers;
    return undef if $self->nph && !_write($res, 'get_start_line_chunk');
    
    # Response headers
    my $code = $res->code    || 404;
    my $msg  = $res->message || $res->default_message;
    $res->headers->status("$code $msg") unless $self->nph;
    return undef                        unless _write($res, 'get_header_chunk');
    
    # Response body
    return undef unless $tx->is_empty || _write($res, 'get_body_chunk');
    
    # Finish transaction
    $tx->closed;
    
    return $res->code;

=cut

  }
  
}

__END__

sub run {
  my $self = shift;

  $self->app->server($self);
  my $tx  = $self->build_tx;
  my $req = $tx->req->parse(\%ENV);
  $tx->local_port($ENV{SERVER_PORT})->remote_address($ENV{REMOTE_ADDR});

  # Request body (may block if we try to read too much)
  binmode STDIN;
  my $len = $req->headers->content_length;
  until ($req->is_finished) {
    my $chunk = ($len && $len < 131072) ? $len : 131072;
    last unless my $read = STDIN->read(my $buffer, $chunk, 0);
    $req->parse($buffer);
    last if ($len -= $read) <= 0;
  }

  $self->emit(request => $tx);

  # Response start-line
  STDOUT->autoflush(1);
  binmode STDOUT;
  my $res = $tx->res->fix_headers;
  return undef if $self->nph && !_write($res, 'get_start_line_chunk');

  # Response headers
  my $code = $res->code    || 404;
  my $msg  = $res->message || $res->default_message;
  $res->headers->status("$code $msg") unless $self->nph;
  return undef                        unless _write($res, 'get_header_chunk');

  # Response body
  return undef unless $tx->is_empty || _write($res, 'get_body_chunk');

  # Finish transaction
  $tx->closed;

  return $res->code;
}

sub _write {
  my ($res, $method) = @_;

  my $offset = 0;
  while (1) {

    # No chunk yet, try again
    sleep 1 and next unless defined(my $chunk = $res->$method($offset));

    # End of part
    last unless my $len = length $chunk;

    # Make sure we can still write
    $offset += $len;
    return undef unless STDOUT->opened;
    print STDOUT $chunk;
  }

  return 1;
}

