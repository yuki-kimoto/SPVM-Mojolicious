# Copyright (c) 2023 Yuki Kimoto
# MIT License

class Mojo::URL {
  version_from Mojolicious;
  
  use StringBuffer;
  use Re;
  use Mojo::Parameters;
  use Mojo::Util;
  
  # Fields
  has base : rw Mojo::URL;
  
  has fragment : rw string;
  
  has host : rw string;
  
  has port : rw int;
  
  has scheme : rw string;
  
  has userinfo : rw string;
  
  has path : rw Mojo::Path
    get {
      unless (exists $self->{path}) {
        $self->{path} = Mojo::Path->new;
      }
      
      return $self->{path};
    }
    
    set ($path : object of string|Mojo::Path) {
      
      unless ($path) {
        die "The path \$path must be defined.";
      }
      
      if ($path isa Mojo::Path) {
        $self->{path} = (Mojo::Path)$path;
      }
      else {
        unless ($self->{path}) {
          $self->{path} = Mojo::Path->new;
        }
        
        $self->{path}->merge((string)$path);
      }
      
    }
  ;
  
  has query : rw Mojo::Parameters
    get {
      
      unless (exists $self->{query}) {
        $self->{query} = Mojo::Parameters->new;
      }
      
      return $self->{query};
    }
    
    set ($query_value : object of object[]|Mojo::Parameters)  {
      
      unless ($query_value) {
        die "The query \$query_value must be defined.";
      }
      
      unless ($self->{query}) {
        $self->{query} = Mojo::Parameters->new;
      }
      
      # Merge with hash
      if (is_options $query_value) {
        $self->{query}->merge($query_value);
      }
      
      # Append array
      elsif ($query_value isa object[]) {
        $self->{query}->append($query_value);
      }
      
      # New parameters
      elsif ($query_value isa Mojo::Parameters) {
        $self->{query} = (Mojo::Parameters)$query_value;
      }
      else {
        die "The type query value \$query_value must be object[] or Mojo::Parameters.";
      }
    }
  ;
  
  # Class Methods
  static method new : Mojo::URL ($url : string = undef) {
    
    my $self = new Mojo::URL;
    
    if ($url) {
      $self->parse($url);
    }
    
    return $self;
  }
  
  # Instance Methods
  method clone : Mojo::URL () {
    
    my $clone = Mojo::URL->new;
    
    $clone->{fragment} = $self->{fragment};
    $clone->{host} = $self->{host};
    $clone->{port} = $self->{port};
    $clone->{scheme} = $self->{scheme};
    $clone->{userinfo} = $self->{userinfo};
    
    if ($self->{base}) {
      $clone->{base} = $self->{base}->clone;
    }
    
    if ($self->{path}) {
      $clone->{path} = $self->{path}->clone;
    }
    
    if ($self->{query}) {
      $clone->{query} = $self->{query}->clone;
    }
    
    return $clone;
  }
  
  method host_port : string () {
    
    my $host = $self->ihost;
    unless ($host) {
      return undef ;
    }
    
    my $port = $self->port;
    unless ($port) {
      return $host;
    }
    
    return "$host:$port";
  }
  
  method set_host_port : void ($host_port : string) {
    
    my $host_port_ref = [$host_port];
    if (my $replace_info = Re->s($host_port_ref, ":(\d+)$", "")) {
      my $match = $replace_info->match;
      $self->set_port((int)$match->cap1);
    }
    $host_port = $host_port_ref->[0];
    
    my $host = Mojo::Util->url_unescape($host_port);
    
    if (Re->m($host, "[^\x00-\x7f]")) {
      $self->set_ihost($host);
    }
    else {
      $self->set_host($host);
    }
  }
  
  method ihost : string () {
    
    my $host = $self->host;
    unless ($host) {
      return undef;
    }
    
    unless (Re->m($host, "[^\x00-\x7f]")) {
      return $host;
    }
    
    my $parts = Fn->split(".", $host, -1);
    
    my $parts_punycode_encoded = (string[])Fn->map(method : string ($part : string) {
      if (my $match = Re->m($part, "[^\x00-\x7f]")) {
        return  "xn--" . Mojo::Util->punycode_encode($match->cap1);
      }
      else {
        return $part;
      }
    }, $parts);
    
    my $ihost = Fn->join(".", $parts_punycode_encoded);
    
    return $ihost;
  }
  
  method set_ihost : void ($ihost : string) {
    
    my $parts = Fn->split(".", $ihost, -1);
    
    my $parts_punycode_decoded = (string[])Fn->map(method : string ($part : string) {
      if (my $match = Re->m($part, "^xn--(.+)$")) {
        return  Mojo::Util->punycode_decode($match->cap1);
      }
      else {
        return $part;
      }
    }, $parts);
    
    my $host = Fn->join(".", $parts_punycode_decoded);
    
    $self->set_host($host);
  }
  
  method is_abs : int () {
    return !!$self->scheme;
  }
  
  method parse : void ($url : string) {
    
    # Official regex from RFC 3986
    if (my $match = Re->m($url, "^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?")) {
      
      if ($match->cap2) {
        $self->set_scheme($match->cap2);
      }
      
      if ($match->cap5) {
        $self->set_path(Mojo::Path->new($match->cap5));
      }
      
      if ($match->cap7) {
        $self->set_query(Mojo::Parameters->new($match->cap7));
      }
      
      if ($match->cap9) {
        $self->set_fragment(Mojo::Util->url_unescape($match->cap9));
      }
      
      if (my $auth = $match->cap4) {
        
        my $auth_ref = [$auth];
        if (my $replace_info = Re->s($auth_ref, "^([^\@]+)\@", "")) {
          my $match = $replace_info->match;
          $self->set_userinfo(Mojo::Util->url_unescape($match->cap1)) ;
        }
        $auth = $auth_ref->[0];
        
        $self->set_host_port($auth);
      }
    }
  }
  
  method password : string () {
    
    my $userinfo = "";
    if ($self->userinfo) {
      $userinfo = $self->userinfo;
    }
    
    my $password = (string)undef;
    if (my $match = Re->m($userinfo, ":(.*)$")) {
      $password = $match->cap1;
    }
    
    return $password;
  }
  
  method path_query : string () {
    
    my $query = $self->query->to_string;
    
    my $path_query = $self->path->to_string;
    
    if (length $query) {
      $path_query .= "?$query";
    }
    
    return $path_query;
  }
  
  method set_path_query : void ($pass_query : string) {
    
    if (my $match = Re->m($pass_query, "^([^?#]*)(?:\?([^#]*))?")) {
      if ($match->cap2) {
        $self->set_path(Mojo::Path->new($match->cap1));
        $self->set_query(Mojo::Parameters->new($match->cap2));
      }
      else {
        $self->set_path(Mojo::Path->new($match->cap1));
      }
    }
    
  }
  
  method protocol : string () {
    
    my $protocol = "";
    if (my $scheme = $self->scheme) {
      $protocol = Fn->lc($scheme);
    }
    
    return $protocol;
  }
  
  method to_abs : Mojo::URL ($base : Mojo::URL = undef) {
    
    my $abs = $self->clone;
    
    if ($abs->is_abs) {
      return $abs;
    }
    
    # Scheme
    unless ($base) {
      $base = $abs->base;
    }
    $abs->set_base($base);
    $abs->set_scheme($base->scheme);
    
    # Authority
    if ($abs->host) {
      return $abs;
    }
    $abs->set_userinfo($base->userinfo);
    $abs->set_host($base->host);
    $abs->set_port($base->port);
    
    # Absolute path
    my $path = $abs->path;
    if ($path->leading_slash) {
      return $abs;
    }
    
    # Inherit path
    if (!@{$path->parts}) {
      my $abs_path = $base->path->clone;
      $abs_path->canonicalize;
      $abs->set_path($abs_path);
      
      # Query
      unless (length $abs->query->to_string) {
        $abs->set_query($base->query->clone);
      }
    }
    
    # Merge paths
    else {
      my $abs_path = $base->path->clone;
      $abs_path->merge($path);
      $abs_path->canonicalize;
      $abs->set_path($abs_path);
    }
    
    return $abs;
  }

  method to_string : string () {
    return $self->_string(0);
  }
  
  method to_unsafe_string : string () {
    return $self->_string(1);
  }
  
  method username : string () {
    
    my $userinfo = "";
    if ($self->userinfo) {
      
    }
    
    my $username = (string)undef;
    if (my $match = Re->m($username, "^([^:]+)")) {
      $username = $match->cap1;
    }
    
    return $username;
  }
  
  private method _string : string ($unsafe : int) {
    
    # Scheme
    my $url = "";
    if (my $proto = $self->protocol) {
      $url .= "$proto:";
    }
    
    # Authority
    my $auth = $self->host_port;
    if ($auth) {
      $auth = Mojo::Util->url_escape($auth, q'^A-Za-z0-9\\-._~!$&\'()*+,;=:\\[\\]');
    }
    
    my $info = $self->userinfo;
    if ($unsafe && $info) {
      $auth = Mojo::Util->url_escape(q'^A-Za-z0-9\\-._~!$&\'()*+,;=:') . "@" . $auth;
    }
    
    if ($auth) {
      $url .= "//$auth";
    }
    
    # Path and query
    my $path = $self->path_query;
    if (!$auth || !length $path || Re->m($path, "^[/?]")) {
      $url .= $path;
    }
    else {
      $url .= "/$path";
    }
    
    # Fragment
    my $fragment = $self->fragment;
    unless (length $fragment) {
      return $url;
    }
    
    $url .= "#" . Mojo::Util->url_escape($fragment, q'^A-Za-z0-9\\-._~!$&\'()*+,;=:@/?');
    
    return $url;
  }
  
}
