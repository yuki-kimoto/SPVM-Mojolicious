# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Mojo::Transaction extends Mojo::EventEmitter {
  version_from Mojolicious;
  
  use Mojo::Message::Request;
  use Mojo::Message::Response;
  use Mojo::Util;
  use Hash;
  
  # Fields
  has kept_alive : rw byte;
  
  has local_address : rw string;
  
  has local_port : rw int;
  
  has original_remote_address : rw string;
  
  has remote_address : virtual rw string
    get {
      
      unless ($self->req->reverse_proxy) {
        return $self->original_remote_address;
      }
      
      my $x_forwarded_for = $self->req->headers->header("X-Forwarded-For");
      unless ($x_forwarded_for) {
        $x_forwarded_for = "";
      }
      
      my $addrs   = Re->split("\s*,\s*", $x_forwarded_for);
      my $trusted = $self->req->trusted_proxies;
      
      unless (@$trusted) {
        if (@$addrs) {
          return $addrs->[@$addrs - 1];
        }
        else {
          return $self->original_remote_address;
        }
      }
      
      $addrs = Array->merge_string($addrs, [$self->original_remote_address]);
      
      Fn->reverse_inplace($addrs);
      
      for my $addr (@$addrs) {
        my $matches = Fn->grep([$addr : string] method : int ($_ : string) { return Mojo::Util->network_contains($_, $addr); }, $trusted);
        
        unless (@$matches) {
          return $addr ;
        }
      }
      
      return $addrs->[0];
    }
    
    set {
      
      $self->{original_remote_address} = $_;
    }
  ;
  
  has remote_port : rw int;
  
  has req : rw Mojo::Message::Request
    get {
      unless (exists $self->{req}) {
        $self->{req} = Mojo::Message::Request->new;
      }
      
      return $self->{req};
    }
  ;
  
  has res : rw Mojo::Message::Response
    get {
      unless (exists $self->{res}) {
        $self->{res} = Mojo::Message::Response->new;
      }
      
      return $self->{res};
    }
  ;
  
  has connection : rw string
    set {
      
      $self->{connection} = $_;
      
      $self->emit(connection => $_);
    }
  ;
  
  # Undocumented Fields
  has completed : byte;
  
  # Class Methods
  static method new : Mojo::Transaction () {
    
    my $self = new Mojo::Transaction;
    
    $self->init;
    
    return $self;
  }
  
  protected method init : void ($options : object[] = undef) {
    
  }
  
  # Instance Methods
  method client_read : void ($chunk : string) { die "Not implemented."; }
  
  method client_write : string ($server : int) { die "Not implemented."; }
  
  method closed : void () {
    
    $self->completed;
    
    $self->emit("finish");
  }
  
  method completed : void () {
    $self->{completed} = 1;
  }
  
  method is_finished : int () {
    
    return !!$self->{completed};
  }
  
  method is_websocket : int () {
    return 0;
  }
  
  method result : Mojo::Message::Response () {
    
    my $result = $self->res;
    
    return $result;
  }
  
  method server_read : void ($chunk : string) { die "Not implemented."; }
  
  method server_write : string ($server : int) { die "Not implemented."; }

}

